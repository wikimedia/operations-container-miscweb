<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
  <head>
    <title>Bug 164 &ndash; Support collation by a certain locale (sorting order of characters)</title>

      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<link rel="Top" href="https://old-bugzilla.wikimedia.org/">

  


  
    <link rel="Show" title="Dependency Tree"
          href="showdependencytree.cgi?id=164&amp;hide_resolved=1">
      <link rel="Show" title="Dependency Graph"
            href="showdependencygraph.cgi?id=164">

      <link rel="Show" title="Bug Activity"
            href="show_activity.cgi?id=164">
      <link rel="Show" title="Printer-Friendly Version"
            href="show_bug.cgi?format=multiple&amp;id=164">



    
    <link href="skins/standard/global.css?1389015166"
          rel="alternate stylesheet" 
          title="Classic"><link href="js/yui/assets/skins/sam/autocomplete.css?1389015166" rel="stylesheet"
        type="text/css" ><link href="js/yui/assets/skins/sam/calendar.css?1389015166" rel="stylesheet"
        type="text/css" ><link href="skins/standard/global.css?1389015166" rel="stylesheet"
        type="text/css" ><link href="skins/standard/show_bug.css?1389015166" rel="stylesheet"
        type="text/css" ><link href="extensions/Voting/web/style.css?1389015166" rel="stylesheet"
        type="text/css" ><!--[if lte IE 7]>
      


  <link href="skins/standard/IE-fixes.css?1389015166" rel="stylesheet"
        type="text/css" >
<![endif]-->

    <link href="skins/contrib/Wikimedia/global.css?1402013050" rel="stylesheet"
        type="text/css" title="Wikimedia"><link href="skins/contrib/Wikimedia/show_bug.css?1402441020" rel="stylesheet"
        type="text/css" title="Wikimedia">

      <link rel="stylesheet" href="skins/contrib/Wikimedia/vector.css?1403109885" media="screen"
            title="Wikimedia" />


    

    

    
<script type="text/javascript" src="js/yui/yahoo-dom-event/yahoo-dom-event.js?1389015166"></script><script type="text/javascript" src="js/yui/cookie/cookie-min.js?1389015166"></script><script type="text/javascript" src="js/yui/datasource/datasource-min.js?1389015166"></script><script type="text/javascript" src="js/yui/connection/connection-min.js?1389015166"></script><script type="text/javascript" src="js/yui/json/json-min.js?1389015166"></script><script type="text/javascript" src="js/yui/autocomplete/autocomplete-min.js?1389015166"></script><script type="text/javascript" src="js/yui/calendar/calendar-min.js?1389015166"></script><script type="text/javascript" src="js/global.js?1389015166"></script>

    <script type="text/javascript">
    <!--
        YAHOO.namespace('bugzilla');
        YAHOO.util.Event.addListener = function (el, sType, fn, obj, overrideContext) {
               if ( ("onpagehide" in window || YAHOO.env.ua.gecko) && sType === "unload") { sType = "pagehide"; };
               var capture = ((sType == "focusin" || sType == "focusout") && !YAHOO.env.ua.ie) ? true : false;
               return this._addListener(el, this._getType(sType), fn, obj, overrideContext, capture);
         };
        if ( "onpagehide" in window || YAHOO.env.ua.gecko) {
            YAHOO.util.Event._simpleRemove(window, "unload", 
                                           YAHOO.util.Event._unload);
        }
        
        function unhide_language_selector() { 
            YAHOO.util.Dom.removeClass(
                'lang_links_container', 'bz_default_hidden'
            ); 
        } 
        YAHOO.util.Event.onDOMReady(unhide_language_selector);

        
        var BUGZILLA = {
            param: {
                cookiepath: '\/',
                maxusermatches: 15
            },
            constant: {
                COMMENT_COLS: 80
            },
            string: {
                

                attach_desc_required:
                    'You must enter a Description for this attachment.',
                component_required:
                    'You must select a Component for this bug.',
                description_required:
                    'You must enter a Description for this bug.',
                short_desc_required:
                    'You must enter a Summary for this bug.',
                version_required:
                    'You must select a Version for this bug.'
            }
        };

    if (history && history.replaceState) {
      if(!document.location.href.match(/show_bug\.cgi/)) {
        history.replaceState( null, 
                             "Bug 164 – Support collation by a certain locale (sorting order of characters)",  
                             "show_bug.cgi?id=164" );
        document.title = "Bug 164 – Support collation by a certain locale (sorting order of characters)";
      }
      if (document.location.href.match(/show_bug\.cgi\?.*list_id=/)) {
        var href = document.location.href;
        href = href.replace(/[\?&]+list_id=(\d+|cookie)/, '');
        history.replaceState(null, "Bug 164 – Support collation by a certain locale (sorting order of characters)", href);
      }
    }
    YAHOO.util.Event.onDOMReady(function() {
      initDirtyFieldTracking();
    });
    // -->
    </script>
<script type="text/javascript" src="js/util.js?1389015166"></script><script type="text/javascript" src="js/field.js?1389015166"></script>

    

    
    <link rel="search" type="application/opensearchdescription+xml"
                       title="Bugzilla" href="./search_plugin.cgi">
    <link rel="shortcut icon" href="images/favicon.ico" >
  </head>



  <body onload=""
        class="old-bugzilla-wikimedia-org bz_bug bz_status_RESOLVED bz_product_MediaWiki bz_component_Internationalization bz_bug_164 yui-skin-sam">



<!-- If custom Wikimedia skin -->
   <div id="page-base" class="noprint"></div>
                <div id="head-base" class="noprint"></div>
                <!-- content -->
                <div id="content-container" >
                        <a id="top"></a>
                        <!-- bodyContent -->
                        <div id="bodyContent">
      <p class="header_addl_info">Last modified: 2014-11-17 09:21:37 UTC</p>

 <!-- If custom Wikimedia skin -->
<h1>Wikimedia Bugzilla is closed!</h1><div id="message" style="text-align: center; color: black">Wikimedia has <a href="https://www.mediawiki.org/wiki/Phabricator/versus_Bugzilla">migrated from Bugzilla to Phabricator</a>. Bug reports should be created and updated in <a href="https://phabricator.wikimedia.org">Wikimedia Phabricator</a> instead. Please <a href="https://www.mediawiki.org/wiki/Phabricator/Help#Creating_your_account">create an account in Phabricator and add your Bugzilla email address</a> to it.<br>Wikimedia Bugzilla is read-only. If you try to edit or create any bug report in Bugzilla you will be shown an intentional error message.<br>In order to access the Phabricator task corresponding to a Bugzilla report, just remove "static-" from its URL.<br>You could still run searches in Bugzilla or access your <a href="https://old-bugzilla.wikimedia.org/page.cgi?id=voting%2Fuser.html">list of votes</a> but bug reports will obviously not be up-to-date in Bugzilla.</div>

<div class="navigation">
  
  <i><font color="#777777">First</font></i>
  <i><font color="#777777">Last</font></i>
  <i><font color="#777777">Prev</font></i>
  <i><font color="#777777">Next</font></i>
  &nbsp;&nbsp;
  <i><font color="#777777">This bug is not in your last
    search results.</font></i>
</div>
<script type="text/javascript">
<!--

//-->
</script>

<form name="changeform" id="changeform" method="post" action="process_bug.cgi">

  <input type="hidden" name="delta_ts" value="2014-11-17 09:21:37">
  <input type="hidden" name="longdesclength" value="238">
  <input type="hidden" name="id" value="164">
  <input type="hidden" name="token" value="1419356685-jU-OHSNgLEJX8Z2ZOckXi90i9TR6G17DefZ0wYfu9bY">
<div class="bz_alias_short_desc_container edit_form">
     <a href="show_bug.cgi?id=164"><b>Bug&nbsp;164</b></a> -<span id="summary_alias_container" class="bz_default_hidden"> 
      <span id="short_desc_nonedit_display">Support collation by a certain locale (sorting order of characters)</span>
     </span>
  
       
    <div id="summary_alias_input">
      <table id="summary"> 
        <tr>
            <td colspan="2">
          </td>
        </tr>
        
        <tr><th class="field_label "
    id="field_label_short_desc">

    <label for="short_desc" accesskey="s">

  <a 
      title="The bug summary is a short sentence which succinctly describes what the bug is about."
      class="field_help_link"
      href="page.cgi?id=fields.html#short_desc"
  >Summary:</a>
</label>
</th>
          <td>Support collation by a certain locale (sorting order of characters)
          </td>
        </tr>
      </table>
    </div>
  </div>
  <script type="text/javascript">
    hideAliasAndSummary('Support collation by a certain locale (sorting order of characters)', '');
  </script>
  <table class="edit_form">
    <tr>
      
      <td id="bz_show_bug_column_1" class="bz_show_bug_column">     
        <table>
          <tr>
    <th class="field_label">
      <a href="page.cgi?id=fields.html#bug_status">Status</a>:
    </th>
    <td id="bz_field_status">
      <span id="static_bug_status">RESOLVED
          FIXED
      </span>
    </td>
  </tr>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
          <tr><th class="field_label "
    id="field_label_product">


  <a 
      title="Bugs are categorised into Products and Components."
      class="field_help_link"
      href="describecomponents.cgi"
  >Product:</a>

</th>
  <td class="field_value "
      id="field_container_product" >MediaWiki</td>
    </tr>

    
    <tr class="bz_default_hidden"><th class="field_label "
    id="field_label_classification">


  <a 
      title="Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation."
      class="field_help_link"
      href="page.cgi?id=fields.html#classification"
  >Classification:</a>

</th>
  <td class="field_value "
      id="field_container_classification" >Unclassified</td>
    </tr>
        
    
    
    <tr>
    
    <td class="field_label">
      <label for="component">
        <a href="describecomponents.cgi?product=MediaWiki">
        Component:</a>
      </label>
    </td>
    
    <td>Internationalization
    
    (<a href="buglist.cgi?component=Internationalization&product=MediaWiki&resolution=---"
      target="new_window">Other open bugs</a>)
    
    </td>
    </tr>
    <tr><th class="field_label "
    id="field_label_version">

    <label for="version">

  <a 
      title="The version field defines the version of the software the bug was found in."
      class="field_help_link"
      href="page.cgi?id=fields.html#version"
  >Version:</a>
</label>
</th>
        <td>unspecified
  </td>
    </tr>
        
    
        
    <tr><th class="field_label "
    id="field_label_rep_platform">

    <label for="rep_platform" accesskey="h">

  <a 
      title="The hardware platform the bug was observed on. Note: When searching, selecting the option &quot;All&quot; only finds bugs whose value for this field is literally the word &quot;All&quot;."
      class="field_help_link"
      href="page.cgi?id=fields.html#rep_platform"
  >Hardware:</a>
</label>
</th>
      <td class="field_value">All
       All
      </td>
    </tr>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
          
          <tr>
      <th class="field_label">
        <label for="priority" accesskey="i">
          <a href="page.cgi?id=fields.html#importance"><u>I</u>mportance</a></label>:
      </th>
      <td>Normal
       major<span id="votes_container">
      with
      <a href="page.cgi?id=voting/bug.html&amp;bug_id=164">109 
            votes</a>
    (<a href="page.cgi?id=voting/user.html&amp;bug_id=164#vote_164">vote</a>)
  </span>
      </td>
    </tr>

      <tr>
        <th class="field_label">
          <label for="target_milestone">
            <a href="page.cgi?id=fields.html#target_milestone">
            Target&nbsp;Milestone</a></label>:
        </th><td>---
  </td>
      </tr>            
          
          <tr>
      <th class="field_label">
        <a href="page.cgi?id=fields.html#assigned_to">Assigned To</a>:
      </th>
      <td><span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
      </td>
    </tr>

    <script type="text/javascript">
      assignToDefaultOnChange(['product', 'component'],
        'wikibugs-l\x40lists.wikimedia.org',
        '');
    </script>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
          <tr><th class="field_label "
    id="field_label_bug_file_loc">

    <label for="bug_file_loc" accesskey="u">

  <a 
      title="Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen."
      class="field_help_link"
      href="page.cgi?id=fields.html#bug_file_loc"
  >URL:</a>
</label>
</th>
    <td>
      <span id="bz_url_input_area">
          <a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale"><span title="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale">http://www.mediawiki.org/wiki/Bugzill...
        </span></a>
      </span>
    </td>
  </tr>
  
    <tr><th class="field_label "
    id="field_label_status_whiteboard">

    <label for="status_whiteboard" accesskey="w">

  <a 
      title="Each bug has a free-form single line text entry box for adding tags and status information."
      class="field_help_link"
      href="page.cgi?id=fields.html#status_whiteboard"
  >Whiteboard:</a>
</label>
</th><td colspan="2">  
  </td>
    </tr>
  
    <tr>
      <th class="field_label">
        <label for="keywords" accesskey="k">
          <a href="describekeywords.cgi"><u>K</u>eywords</a></label>:
      </th>
      <td class="field_value" colspan="2">i18n, schema-change, upstream
      </td>
    </tr>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>

          <tr>
    <th class="field_label">
      <label for="duplicates">Duplicates</label>:
    </th>
    <td class="field_value" colspan="2">
      <span id="duplicates"><a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Danish letters has wrong sort order"
   href="show_bug.cgi?id=353">353</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Wrong alphabetical order in Special:Allpages"
   href="show_bug.cgi?id=608">608</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Collation sequence is case-sensitive"
   href="show_bug.cgi?id=1304">1304</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical ordering in Turkish language"
   href="show_bug.cgi?id=2489">2489</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical order wrong on (some?) non-english Wiki's."
   href="show_bug.cgi?id=2602">2602</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">2628</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - category sorting cannot handle Thai words properly"
   href="show_bug.cgi?id=2818">2818</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Problem sorting accented caracteres"
   href="show_bug.cgi?id=3343">3343</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Provide a setup to order pages at [[special:Allpages]] completaly case insensitive regardles of the value of $wgCapitalLinks"
   href="show_bug.cgi?id=4622">4622</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - an enhacement in categories"
   href="show_bug.cgi?id=4963">4963</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Double character support in category pages"
   href="show_bug.cgi?id=6928">6928</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Ё and ё ordering for Russian alphabet is incorrect"
   href="show_bug.cgi?id=9247">9247</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Sort items in categories according language alphabet order"
   href="show_bug.cgi?id=9614">9614</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Every category page doesn't sort article Bulgarian (cyrillic) names correctly"
   href="show_bug.cgi?id=10771">10771</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Order of pages with Persian titles"
   href="show_bug.cgi?id=10846">10846</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Incorrect sorting of articles on category pages"
   href="show_bug.cgi?id=10966">10966</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Please allow correct alphabetic order in Categories"
   href="show_bug.cgi?id=11322">11322</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical order in tr.wikipedia"
   href="show_bug.cgi?id=11503">11503</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Words beginning with ө, ү, and ё"
   href="show_bug.cgi?id=13093">13093</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Add sort key to entries in Special:Specialpages"
   href="show_bug.cgi?id=17260">17260</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - 'edit watchlist' sorting issue, plus bonus complaint"
   href="show_bug.cgi?id=18599">18599</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Capital letters are always sorted first"
   href="show_bug.cgi?id=19197">19197</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Special:PrefixIndex and Special:AllPages have wrong ordering"
   href="show_bug.cgi?id=19279">19279</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical ordering in Turkmen language"
   href="show_bug.cgi?id=19967">19967</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Simplify default sortkey for portuguese (better collation support for categories)"
   href="show_bug.cgi?id=24142">24142</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Invalid sorting (collation problem)"
   href="show_bug.cgi?id=24953">24953</a> <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetization of categories in Turkish Wikimedia projects"
   href="show_bug.cgi?id=25129">25129</a> 
      </span>
      (<a href="buglist.cgi?bug_id=353,608,1304,2489,2602,2628,2818,3343,4622,4963,6928,9247,9614,10771,10846,10966,11322,11503,13093,17260,18599,19197,19279,19967,24142,24953,25129">view as bug list</a>)
    </td>
  </tr>
<tr><th class="field_label "
    id="field_label_dependson">


  <a 
      title="The bugs listed here must be resolved before this bug can be resolved."
      class="field_help_link"
      href="page.cgi?id=fields.html#dependson"
  >Depends on:</a>

</th>

  <td>
    <span id="dependson_input_area">
    </span>
    
  </td>
  </tr>
  
  <tr><th class="field_label "
    id="field_label_blocked">


  <a 
      title="This bug must be resolved before the bugs listed in this field can be resolved."
      class="field_help_link"
      href="page.cgi?id=fields.html#blocked"
  >Blocks:</a>

</th>

  <td>
    <span id="blocked_input_area">
    </span>
    <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Unicode (UTF-8, utf8) compatibility (tracking)"
   href="show_bug.cgi?id=3969">unicode</a> <a class="bz_bug_link 
          bz_status_REOPENED "
   title="REOPENED - Natural number sorting in category listings"
   href="show_bug.cgi?id=6948">6948</a> 
  </td>
  </tr>
  
  <tr>
    <th>&nbsp;</th>
  
    <td colspan="2" align="left" id="show_dependency_tree_or_graph">
      Show dependency <a href="showdependencytree.cgi?id=164&amp;hide_resolved=1">tree</a>
  
        /&nbsp;<a href="showdependencygraph.cgi?id=164">graph</a>
    </td>
  </tr>
          
        </table>
      </td>
      <td>
        <div class="bz_column_spacer">&nbsp;</div>
      </td>
      
      <td id="bz_show_bug_column_2" class="bz_show_bug_column">
        <table cellpadding="3" cellspacing="1">
        <tr>
    <th class="field_label">
      Reported:
    </th>
    <td>2004-08-18 17:40 UTC by <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
    </td>
  </tr>
  
  <tr>
    <th class="field_label">
      Modified:
    </th>
    <td>2014-11-17 09:21 UTC 
      (<a href="show_activity.cgi?id=164">History</a>)
    </td>
  
  </tr>
         <tr>
      <th class="field_label">
        <label for="newcc" accesskey="a">CC List:</label>
      </th>
      <td>61 
          users
          <span id="cc_edit_area_showhide_container" class="bz_default_hidden">
            (<a href="#" id="cc_edit_area_showhide">show</a>)
          </span>
        <div id="cc_edit_area">
          <br>
            <select id="cc" multiple="multiple" size="5">
                <option value="anon.hui">anon.hui</option>
                <option value="arthit">arthit</option>
                <option value="ayg">ayg</option>
                <option value="bawolff+wn">bawolff+wn</option>
                <option value="benno79">benno79</option>
                <option value="brion">brion</option>
                <option value="bugzilla.wikimedia">bugzilla.wikimedia</option>
                <option value="bugzilla">bugzilla</option>
                <option value="catlow">catlow</option>
                <option value="chriskwonlewis">chriskwonlewis</option>
                <option value="circeus">circeus</option>
                <option value="crangasi2001">crangasi2001</option>
                <option value="dbl2010">dbl2010</option>
                <option value="dionys">dionys</option>
                <option value="domas.mituzas">domas.mituzas</option>
                <option value="dragonlordofxanther">dragonlordofxanther</option>
                <option value="Drilnoth">Drilnoth</option>
                <option value="Eugene.Zelenko">Eugene.Zelenko</option>
                <option value="f-ar">f-ar</option>
                <option value="federicoleva">federicoleva</option>
                <option value="ForoaW">ForoaW</option>
                <option value="gangleri">gangleri</option>
                <option value="greg">greg</option>
                <option value="gtisza">gtisza</option>
                <option value="hanberke7">hanberke7</option>
                <option value="he7d3r+bugs">he7d3r+bugs</option>
                <option value="hippytrail">hippytrail</option>
                <option value="huji.huji">huji.huji</option>
                <option value="hydrogen_cyanide">hydrogen_cyanide</option>
                <option value="juaned">juaned</option>
                <option value="jutiphan">jutiphan</option>
                <option value="lars">lars</option>
                <option value="lejonel">lejonel</option>
                <option value="liangent">liangent</option>
                <option value="mah">mah</option>
                <option value="mail">mail</option>
                <option value="mashiah.davidson">mashiah.davidson</option>
                <option value="michael">michael</option>
                <option value="misoss">misoss</option>
                <option value="monkbel">monkbel</option>
                <option value="mormegil">mormegil</option>
                <option value="niklas.laxstrom">niklas.laxstrom</option>
                <option value="pinar.bugzilla">pinar.bugzilla</option>
                <option value="raylton.sousa">raylton.sousa</option>
                <option value="reza.energy">reza.energy</option>
                <option value="roan.kattouw">roan.kattouw</option>
                <option value="roozbeh">roozbeh</option>
                <option value="s.moaddeli">s.moaddeli</option>
                <option value="siebrand">siebrand</option>
                <option value="some_777">some_777</option>
                <option value="spacebirdy">spacebirdy</option>
                <option value="spm">spm</option>
                <option value="studerby">studerby</option>
                <option value="thecentercannothold">thecentercannothold</option>
                <option value="timwi">timwi</option>
                <option value="to.aru.shiroi.neko">to.aru.shiroi.neko</option>
                <option value="tomchiukc">tomchiukc</option>
                <option value="tstarling">tstarling</option>
                <option value="v85.wikipedia">v85.wikipedia</option>
                <option value="verdy_p">verdy_p</option>
                <option value="webmaster">webmaster</option>
            </select>
        </div>
          <script type="text/javascript">
            hideEditableField( 'cc_edit_area_showhide_container', 
                               'cc_edit_area', 
                               'cc_edit_area_showhide', 
                               '', 
                               '');  
          </script>
      </td>
    </tr>
         <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
<tr><th class="field_label "
    id="field_label_see_also">


  <a 
      title="This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with a comma. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields."
      class="field_help_link"
      href="page.cgi?id=fields.html#see_also"
  >See Also:</a>

</th>
  <td class="field_value "
      id="field_container_see_also" ></td>
    </tr> 
         <tr><th class="field_label "
    id="field_label_cf_browser">


  <a 
      title="Please set this if the described problem seems to happen only in a specific web browser."
      class="field_help_link"
      href="page.cgi?id=fields.html#cf_browser"
  >Web browser:</a>

</th>
  <td class="field_value "
      id="field_container_cf_browser"  colspan="2">---</td>
    </tr>
    <tr><th class="field_label "
    id="field_label_cf_platform">


  <a 
      title="The Mobile Platform the described problem was experienced on."
      class="field_help_link"
      href="page.cgi?id=fields.html#cf_platform"
  >Mobile Platform:</a>

</th>
  <td class="field_value "
      id="field_container_cf_platform"  colspan="2">---</td>
    </tr>
    <tr><th class="field_label  bz_hidden_field"
    id="field_label_cf_hugglebeta">


  <a 
      title="A custom Drop Down field in this installation of Bugzilla."
      class="field_help_link"
      href="page.cgi?id=fields.html#cf_hugglebeta"
  >Assignee Huggle Beta Tester:</a>

</th>
  <td class="field_value  bz_hidden_field"
      id="field_container_cf_hugglebeta"  colspan="2">---</td>
    </tr>
         <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
         
                

        </table>
      </td>
    </tr>
    <tr>
      <td colspan="3">
          <hr id="bz_top_half_spacer">
      </td>
    </tr>
  </table>

  <table id="bz_big_form_parts" cellspacing="0" cellpadding="0"><tr>
  <td>

    
<script type="text/javascript">
<!--
function toggle_display(link) {
    var table = document.getElementById("attachment_table");
    var view_all = document.getElementById("view_all");
    var hide_obsolete_url_parameter = "&hide_obsolete=1";
    // Store current height for scrolling later
    var originalHeight = table.offsetHeight;
    var rows = YAHOO.util.Dom.getElementsByClassName(
        'bz_tr_obsolete', 'tr', table);

    for (var i = 0; i < rows.length; i++) {
        bz_toggleClass(rows[i], 'bz_default_hidden');
    }

    if (YAHOO.util.Dom.hasClass(rows[0], 'bz_default_hidden')) {
        link.innerHTML = "Show Obsolete";
        view_all.href = view_all.href + hide_obsolete_url_parameter 
    }
    else {
        link.innerHTML = "Hide Obsolete";
        view_all.href = view_all.href.replace(hide_obsolete_url_parameter,"");
    }

    var newHeight = table.offsetHeight;
    // This scrolling makes the window appear to not move at all.
    window.scrollBy(0, newHeight - originalHeight);

    return false;
}
//-->
</script>

<br>
<table id="attachment_table" cellspacing="0" cellpadding="4">
  <tr id="a0">
    <th colspan="2" align="left">
      Attachments
    </th>
  </tr>


      <tr id="a1" class="bz_contenttype_application_zip">
        <td valign="top">
            <a href="attachment.cgi?id=4632"
               title="View the content of the attachment">
          <b>Thai sorting function
See comment #61</b></a>

          <span class="bz_attach_extra_info">
              (2.68 KB,
                application/zip)

            <br>
            <a href="#attach_4632"
               title="Go to the comment associated with the attachment">2008-02-08 06:30 UTC</a>,

            <span class="vcard"><span class="fn">Octra Bond</span>
</span>
          </span>
        </td>


        <td valign="top">
          <a href="attachment.cgi?id=4632&amp;action=edit">Details</a>
        </td>
      </tr>
      <tr id="a2" class="bz_contenttype_application_7z">
        <td valign="top">
            <a href="attachment.cgi?id=5669"
               title="View the content of the attachment">
          <b>sorting orders patch for Chinese language</b></a>

          <span class="bz_attach_extra_info">
              (249.66 KB,
                application/7z)

            <br>
            <a href="#attach_5669"
               title="Go to the comment associated with the attachment">2009-01-13 11:54 UTC</a>,

            <span class="vcard"><span class="fn">Philip Tzou</span>
</span>
          </span>
        </td>


        <td valign="top">
          <a href="attachment.cgi?id=5669&amp;action=edit">Details</a>
        </td>
      </tr>

  <tr class="bz_attach_footer">
    <td colspan="2">
        <span class="bz_attach_view_hide">
        </span>
        <a href="attachment.cgi?bugid=164&amp;action=enter">Add an attachment</a>
        (proposed patch, testcase, etc.)
    </td>
  </tr>
</table>
<br>

  </td>
  <td>
  </td>
  </tr></table>

  
  <div id="comments"><script src="js/comments.js?1389015166" type="text/javascript">
</script>

<script type="text/javascript">
<!--
  /* Adds the reply text to the `comment' textarea */
  function replyToComment(id, real_id, name) {
      var prefix = "(In reply to " + name + " from comment #" + id + ")\n";
      var replytext = "";
        /* pre id="comment_name_N" */
        var text_elem = document.getElementById('comment_text_'+id);
        var text = getText(text_elem);
        replytext = prefix + wrapReplyText(text);


      /* <textarea id="comment"> */
      var textarea = document.getElementById('comment');
      if (textarea.value != replytext) {
          textarea.value += replytext;
      }

      textarea.focus();
  } 
//-->
</script>




<!-- This auto-sizes the comments and positions the collapse/expand links 
     to the right. -->
<table class="bz_comment_table" cellpadding="0" cellspacing="0"><tr>
<td>
<div id="c0" class="bz_comment bz_first_comment">

      <div class="bz_first_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c0">Description</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-08-18 17:40:41 UTC
        </span>
      </div>



<pre class="bz_comment_text" >National wikipedias still have to bear English sorting order, which orders the accented characters 
outside of normal sort which is &quot;not acceptable&quot; for the languages. 
This problem is most visible in the rise of Categories, but present in every automatic list, like 
Allpages or the list of registered editors.

I would guess either mySQL or PHP can utilise national locales/collation orders which would simply 
require the sites to specify their locale and there we go. Or do I guess it wrong? (I am only 
familiar with perl and postgres, where this works.)</pre>
    </div><div id="c1" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c1">Comment 1</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-09-30 18:22:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Danish letters has wrong sort order"
   href="show_bug.cgi?id=353">Bug 353</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c2" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c2">Comment 2</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-09-30 18:23:23 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Wrong alphabetical order in Special:Allpages"
   href="show_bug.cgi?id=608">Bug 608</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c3" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c3">Comment 3</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-09-30 18:27:17 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Just a note: English sort order is not used, but rather the raw order of the characters as they appear in Unicode.

MySQL's collation options are useless as they are server-wide and (through 4.0.x) don't support Unicode. We likely need to add a sort key field that 
we generate ourselves, appropriate for each language.

Probably relevant: <a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a></pre>
    </div><div id="c4" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c4">Comment 4</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Jamesday</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-09-30 18:58:08 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Or we could wait for the character set support in version 4.1, due for release
within a month or two. <a href="http://dev.mysql.com/doc/mysql/en/Charset.html">http://dev.mysql.com/doc/mysql/en/Charset.html</a></pre>
    </div><div id="c5" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c5">Comment 5</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Antoine &quot;hashar&quot; Musso (WMF)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-11-09 15:12:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Subcategories are only partially sorted (multiple &quot;runs&quot;)"
   href="show_bug.cgi?id=616">Bug 616</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c6" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c6">Comment 6</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2004-12-09 08:43:30 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Any progress on #4 ? I don't use mysql, so I couldn't guess whether it's looking became useful or not.</pre>
    </div><div id="c7" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c7">Comment 7</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Klaus-Eduard Runnel</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-01-21 03:30:06 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'd like to point out that there can be Categories on national Wikis which
should be sorted using locale matching some third language. E.g. there is a
French-specific Category on Estonian Wiktionary (Vikisõnaraamat).</pre>
    </div><div id="c8" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c8">Comment 8</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-01-21 13:21:00 UTC
        </span>
      </div>



<pre class="bz_comment_text" >re #7: It is true, it is valid, but I believe it's a minority problem. 

A national wikipedia probably sorts 99% of its lists (categories) by using the
local sorting order.
This is actually possible using per-db collating order.

I don't know how problematic would be to do the sorting in PHP, which would make
it possible to have whatever order anyone please. I still wonder how unicode will
sort under mysql 4.1...

Oh, 4.1 seem to be out for a while now (I know that's not news to you ppl :))
</pre>
    </div><div id="c9" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c9">Comment 9</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-01-29 07:12:27 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Collation sequence is case-sensitive"
   href="show_bug.cgi?id=1304">Bug 1304</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c10" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c10">Comment 10</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">zhengzhu</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-03-07 04:05:36 UTC
        </span>
      </div>



<pre class="bz_comment_text" >A simple implementation for this is running at <a href="http://tinyurl.com/5l24b">http://tinyurl.com/5l24b</a></pre>
    </div><div id="c11" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c11">Comment 11</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ævar Arnfjörð Bjarmason</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-04-09 00:53:06 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Changed the summary to better reflect what the bug is about.</pre>
    </div><div id="c12" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c12">Comment 12</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">peter green</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-04-09 01:16:37 UTC
        </span>
      </div>



<pre class="bz_comment_text" >also remember you can set the sort key of an article manually for categories by
using [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3Acategoryname">category:categoryname</a>|sortkey]]</pre>
    </div><div id="c13" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c13">Comment 13</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-04-09 09:10:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >re: #12
It is not about &quot;just&quot; sorting articles in categories, but - for example -
sorting of THE CATEGORY KEYS. You cannot force it, and even if you could, it
would be very very very messy.
But naturally sorting is everywhere in WP, from all_articles to
registered_users... even if the most visible spot is category sort. But that's
another matter, if categories could be fixed that would silence most of us
complainers for a while. :)
</pre>
    </div><div id="c14" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c14">Comment 14</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-06-22 15:36:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical ordering in Turkish language"
   href="show_bug.cgi?id=2489">Bug 2489</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c15" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c15">Comment 15</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-06-29 09:11:52 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical order wrong on (some?) non-english Wiki's."
   href="show_bug.cgi?id=2602">Bug 2602</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c16" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c16">Comment 16</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ævar Arnfjörð Bjarmason</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-04 18:08:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">Bug 2628</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c17" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c17">Comment 17</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-04 19:54:49 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">Bug 2628</a> was just closed as a duplicate of this bug, but it deals with case-sensitivity which 
is quite independent to locale. In fact on Wiktionary where all languages share a namespace, 
locale sorting doesn't make sense unless it can be set on a per-category basis.

If <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">Bug 2628</a> was closed because a fix is due which will take care of both locale and case-
sensitivity, then perhaps it would be prudent to mention case in the summary.
</pre>
    </div><div id="c18" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c18">Comment 18</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-12 11:09:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - category sorting cannot handle Thai words properly"
   href="show_bug.cgi?id=2818">Bug 2818</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c19" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c19">Comment 19</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Arthit Suriyawongkul</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-13 22:00:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" >from <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - category sorting cannot handle Thai words properly"
   href="show_bug.cgi?id=2818">Bug 2818</a>,
in order to handle many locale/language-specific sorting perferences,
may be we can have a mechanism that allow contributor to specify the sorting
preference of each category.

may be we can add something like this to the category page,

[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category-sort-option%3Asort_option">Category-sort-option:sort_option</a>]]

for examples:

[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category-sort-option%3Aen-GB">Category-sort-option:en-GB</a>]]
[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category-sort-option%3Aja">Category-sort-option:ja</a>]]
[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category-sort-option%3Ath">Category-sort-option:th</a>]]


in the case of Wikipedia, this may be optional.
if not presented, use a default one - determined from the language of the Wikipedia.
(in which, may be problematic in the case of languages like English, German,
French, .. which a single language is shared by many countries (locales) .. so
what should be a default ?? -- not a technical question, more &quot;political&quot;.)</pre>
    </div><div id="c20" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c20">Comment 20</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Antoine &quot;hashar&quot; Musso (WMF)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-14 03:49:22 UTC
        </span>
      </div>



<pre class="bz_comment_text" >MediaWiki 1.5 only support UTF-8 charset now.

MySQL 4.1 support UTF8
character set support for InnoDB since 4.1.2

Looks like the issue can be assigned to wikimedia servers
and pending for a mysql 4.1.x upgrade</pre>
    </div><div id="c21" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c21">Comment 21</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-07-14 04:30:36 UTC
        </span>
      </div>



<pre class="bz_comment_text" >1) MediaWiki has no support for collations currently.
2) MySQL's UTF-8 support doesn't support 4-byte characters, according to MySQL docs. It's unknown whether this will cause data 
corruption for some pages and needs to be investigated.
3) It's unknown at this time whether we can make use of collations for sorting without that also infecting equality checks (and 
unique indexes).
4) If 3), the affects of this for creating page name conflicts and other issues is unknown.
5) MySQL may or may not have sufficient collation options.
6) We may want this option without requiring particular versions of MySQL.
</pre>
    </div><div id="c22" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c22">Comment 22</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-08-10 02:10:11 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Since nobody has commented on the capitalisation issue at all here which I
opened as <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">Bug 2628</a> and mentioned above after that bug was incorrectly closed as
a duplicate of this one, I am now re-opening <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">bug 2628</a> as it is clearly a
separate issue soluble without any of the issues brought up here.</pre>
    </div><div id="c23" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c23">Comment 23</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Rick Block</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-08-25 02:48:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Related to this, although perhaps different enough to warrant a separate bug entry (just a note for now) - &quot;case 
insensitivity&quot; with regard to searching should treat accented and unaccented characters as the same.  This would allow, 
for example, an article named &quot;Zürich&quot; to be found by a &quot;Go&quot; search for &quot;Zurich&quot; without requiring creation of a redirect.</pre>
    </div><div id="c24" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c24">Comment 24</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roman Maurer</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-08-25 16:52:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Related to Rick's comment, please note that while Germans consider ü to be &quot;u
with umlaut&quot;, Slovenians consider č to be a separate letter, unrelated to c, so
sorting order should not treat them the same.</pre>
    </div><div id="c25" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c25">Comment 25</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">peter green</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-08-31 19:51:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >one possible option would be to let languages plug in a filter to generate sort
keys from thier text.

basically the functions task would be to take a string of unicode text and
produce a (prefferablly but not nessacerally human readable) string of bytes
from it in any way it wishes such that the output byte strings sort in the
desired way.

e.g. the one for english could be a diacritic stripper ones for languages were
letters with diacritics have a two letter equivilent could make those
replacements etc</pre>
    </div><div id="c26" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c26">Comment 26</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Antoine &quot;hashar&quot; Musso (WMF)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-09-03 14:11:05 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Problem sorting accented caracteres"
   href="show_bug.cgi?id=3343">Bug 3343</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c27" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c27">Comment 27</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ævar Arnfjörð Bjarmason</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-09-11 19:40:43 UTC
        </span>
      </div>



<pre class="bz_comment_text" >severity =&gt; enhancement</pre>
    </div><div id="c28" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c28">Comment 28</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Minh Nguyễn</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-09-12 01:19:07 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Perhaps the per-category sorting, à la <a href="show_bug.cgi?id=164#c19">Comment 19</a>, should be made available only
as an extension to be installed at Wiktionary. I still support per-locale
sorting, however.</pre>
    </div><div id="c29" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c29">Comment 29</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Neil Harris</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-06 11:53:04 UTC
        </span>
      </div>



<pre class="bz_comment_text" >A very crude algorithm for creating sort keys is to normalize the input string
using Unicode normalization form NFKD (&quot;canonical decomposition&quot;), and then
simply delete all combining characters (which are helpfully partitioned into
only four ranges of code points) from the string. 

This quite effectively &quot;de-accents&quot; the text string, as well as converting
ligatures to their component letters, superscript digits to their base digits,
and so on.

For extra thoroughness, you could also case-fold to lowercase at the same time,
and even use some of the extra rules specified in the NAMEPREP RFC to do things
like map ess-zet to &quot;ss&quot;.

Perhaps the sort key for each article title (since that's what most sorts work
on) could be stored somewhere in the database alongside the title, eliminating
the need to recompute it each time it is needed? This would also mean that it
would be possible to use native database sorting to get data in sort order,
without needing a post-processing sort.

Yes, I know this is not the same as implementing true internationalized
collation, but it would be a great deal better than the status quo for all
Latin-character based languages, and would not mess up non-Latin scripts (or if
it did, you could simply fix it by only stripping combining marks _after Latin
letters_).</pre>
    </div><div id="c30" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c30">Comment 30</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Neil Harris</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-06 12:02:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >...and since sorting UTF-8 characters will result in the same order as sorting
by Unicode code point, it should work with all versions of MySQL, regardless of
whether or not they are Unicode-aware.

And, after a little Googling, there seems to be a PHP implementation for Unicode
normalization already written as part of MediaWiki: UTFNormal.php, so all you
need to know are the code point ranges for combining marks, which are:

U+0300 - U+036F: Combining diacritical marks
U+FE20 - U+FE2F: Combining half marks
U+1DC0 - U+1DFF: Combining diacritical marks supplement

I think you can safely ignore the combining diacritical marks for symbols.
 



</pre>
    </div><div id="c31" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c31">Comment 31</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Neil Harris</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-06 12:19:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >...and, finally, to avoid the problem of indeterminate ordering for different
strings which map to the same canonical sort key, doing the SQL query as 

 ... ORDER BY article_sort_key, article_title

will ensure that any two articles with distinct titles will always sort in a
well-defined order.
</pre>
    </div><div id="c32" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c32">Comment 32</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Arthit Suriyawongkul</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-06 13:02:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Canonical decomposition / normalization is a nice idea, for a short term (better
than nothing).
But be warned that, although it will work for many European languages,
it will not work with French
(see: <a href="http://www.unicode.org/unicode/reports/tr10/#Contextual_Sensitivity">http://www.unicode.org/unicode/reports/tr10/#Contextual_Sensitivity</a> )
and some CTL languages, like Thai.

In Thai language, we will considers only consonants in the first comparison,
the vowels in the 2nd run, and tonemarks and other symbols in later runs.

Considering:
(1) กา U+0E01 U+0E32
(2) เก U+0E40 U+0E01
(3) ขา U+0E02 U+0E32

normalization doesn't change any of above terms,
hence terms will sorted like:
(1) (3) (2)
where a preferred one is:
(1) (2) (3)



</pre>
    </div><div id="c33" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c33">Comment 33</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Pablo Saratxaga</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-06 13:39:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >As GNU/Linux operating system is being used on the wikipedia
servers; then a possible solution would be to delegate the
alphabetical string sorting to the the system (glibc and locales); there already
are correct LC_COLLATE defintions
for glibc for almost all languages that have a quite good
number of articles; and for those that don't have yet (or the
languages still to grow) an LC_COLLATE definition could be
easily writen and installed.
I can help with that if needed (I work for Mandriva and part
of my work is actually checking and testing the locales, and
write new ones for whatever new language we are requested
support for; I've already corrected or written from scratch
various glibc sorting order definitions already) </pre>
    </div><div id="c34" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c34">Comment 34</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">lɛʁi לערי ריינהארט</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-10-15 13:17:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >¿is this related to?
<a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED INVALID - Implementing your own alphabetical index?"
   href="show_bug.cgi?id=2900">bug 2900</a>: Implementing your own alphabetical index?</pre>
    </div><div id="c35" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c35">Comment 35</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ævar Arnfjörð Bjarmason</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2005-11-30 03:58:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c34">comment #34</a>)
<span class="quote">&gt; ¿is this related to?
&gt; <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED INVALID - Implementing your own alphabetical index?"
   href="show_bug.cgi?id=2900">bug 2900</a>: Implementing your own alphabetical index?</span >

no</pre>
    </div><div id="c36" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c36">Comment 36</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-01-15 21:06:47 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Provide a setup to order pages at [[special:Allpages]] completaly case insensitive regardles of the value of $wgCapitalLinks"
   href="show_bug.cgi?id=4622">Bug 4622</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c37" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c37">Comment 37</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Arthit Suriyawongkul</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-01-25 22:47:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >What else we need right now for the spec ?
What are still missing ? Where are the points that we have to agreed first ?
 in order to have a spec for an implementation. thx

----

Also, anybody has an idea where this feature is going to be implemented ?
Say, in 1.6 branch or 2.0 branch, for instances.

So we can see if it worth to come up with a workaround (like normalization, etc.
manually) in this while,
or it's better to wait a bit.</pre>
    </div><div id="c38" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c38">Comment 38</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">lɛʁi לערי ריינהארט</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-02-11 23:17:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - an enhacement in categories"
   href="show_bug.cgi?id=4963">Bug 4963</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c39" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c39">Comment 39</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">James</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-24 00:51:44 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I sincerely hope that for each wikipedia language, there can be a specified sorting order, perhaps in the system messages or in its own category in special pages.  
Each language handles the topic differently, some with un/accented characters considered the same (ā, a, á; for example).  If each wiki could determine its sorting 
order on its own, perhaps as a string of characters separated by semi-colons and commas, such as: a,A,ā,Ā; æ, Æ; b,B; c, C; (and so on).  But if this were solved it 
would be a great help to other non-English wikipedias.

James</pre>
    </div><div id="c40" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c40">Comment 40</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">mlewan</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-24 15:57:22 UTC
        </span>
      </div>



<pre class="bz_comment_text" >There is an additional problem with Japanese, which has complicated ways of
sorting, so a separate dictionary is needed to decide how to sort the words. You
cannot tell from just looking at the word 中国 whether it shall be sorted under
&quot;naka&quot; or &quot;chuu&quot; as 中 has both those pronunciations (and a few more ones).
Unicode numbering does not work. I have seen an api to sort according to the
&quot;onyomi&quot; or &quot;kunyomi&quot; of the kanji, but that sorting is as useless as to sort
according to the Unicode number. A separate dictionary with the pronunciation
for each word is the only solution, I know of.</pre>
    </div><div id="c41" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c41">Comment 41</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Minh Nguyễn</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-25 01:13:13 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I think the Unihan Database contains that kind of information.
&lt;<a href="http://www.unicode.org/charts/unihan.html">http://www.unicode.org/charts/unihan.html</a>&gt;</pre>
    </div><div id="c42" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c42">Comment 42</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">mlewan</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-26 07:09:27 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c41">comment #41</a>)
<span class="quote">&gt; I think the Unihan Database contains that kind of information.
&gt; &lt;<a href="http://www.unicode.org/charts/unihan.html">http://www.unicode.org/charts/unihan.html</a>&gt;</span >

The Unihan database knows that 中 can be pronounced chuu or naka, but it doesn't
on its own know that in 中国 the only possible Japanese pronunciation is chuu.
On <a href="http://www.unicode.org/cgi-bin/GetUnihanData.pl?codepoint=4E2D">http://www.unicode.org/cgi-bin/GetUnihanData.pl?codepoint=4E2D</a> you find
compound data, but it is from third party sources. The about page states:

&quot;Chinese and Japanese compound data presented in the on-line database come from
the on-line CEDICT and Jim Breen's EDICT projects. These additional data are not
available in the text-file version.&quot;

Wikimedia could use CEDICT and EDICT, but it may be a detour to try to retrieve
it from unicode.org.</pre>
    </div><div id="c43" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c43">Comment 43</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Sukh</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-31 14:20:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Is there any progress on this?  Gurmukhi sorting order on Punjabi language Wikis
(and indeed on all wikis) does not follow byte order so this is a problem.</pre>
    </div><div id="c44" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c44">Comment 44</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-05-31 18:40:12 UTC
        </span>
      </div>



<pre class="bz_comment_text" >This requires major database alterations and possibly a massive, 
potentially breaking MySQL upgrade. Nothing done to date.
</pre>
    </div><div id="c45" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c45">Comment 45</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Michael Zajac</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-08-09 15:28:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >See also <a class="bz_bug_link 
          bz_status_REOPENED "
   title="REOPENED - Natural number sorting in category listings"
   href="show_bug.cgi?id=6948">Bug 6948</a>: Natural number sorting in category listings</pre>
    </div><div id="c46" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c46">Comment 46</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-08-10 06:01:52 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Categories should use case-insensitive sort"
   href="show_bug.cgi?id=2628">Bug 2628</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c47" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c47">Comment 47</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Matthew W. Jackson</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-08-29 19:16:43 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If another field is going to be added for sort-key, it might be worthwhile to
let the users override the sort-order on a per-article basis.  Technically
speaking, shouldn't &quot;George Washington&quot; be sorted under &quot;Washington, George&quot;. 
Since there's no way for a machine to deduce the proper sort order, leaving it
up to the user is the only way to handle it.

So, if database collation can be used, then one field needs to be added to the
database: A Sort-Title.  If, for whatever reason, database collations are not an
option, two fields need to be added: A Sort-Title and a Sort-Key.  A Sort-Title
field would be unicode test, but a Sort-Key would basically be a binary field
that could be sorted byte-by-byte (or ordinally, or lexigraphically, or whatever
you want to call it).

Adding an override for the sort order to the article would reduce the need for
piped category links, since by default an article would sort by it's sort-title
instead of its title.</pre>
    </div><div id="c48" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c48">Comment 48</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-09-04 15:20:09 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Double character support in category pages"
   href="show_bug.cgi?id=6928">Bug 6928</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c49" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c49">Comment 49</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tisza Gergő</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2006-09-07 09:34:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Double character support in category pages"
   href="show_bug.cgi?id=6928">Bug 6928</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c50" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c50">Comment 50</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Alexander Sigachov</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-03-10 22:09:50 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Ё and ё ordering for Russian alphabet is incorrect"
   href="show_bug.cgi?id=9247">Bug 9247</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c51" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c51">Comment 51</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-04-17 16:52:40 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Sort items in categories according language alphabet order"
   href="show_bug.cgi?id=9614">Bug 9614</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c52" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c52">Comment 52</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-08-08 17:25:56 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Every category page doesn't sort article Bulgarian (cyrillic) names correctly"
   href="show_bug.cgi?id=10771">Bug 10771</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c53" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c53">Comment 53</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-08-17 06:57:20 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Incorrect sorting of articles on category pages"
   href="show_bug.cgi?id=10966">Bug 10966</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c54" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c54">Comment 54</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Rob Church</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-08-22 05:43:24 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Order of pages with Persian titles"
   href="show_bug.cgi?id=10846">Bug 10846</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c55" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c55">Comment 55</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">nav</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-08-24 13:06:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Hi Guys,
Do you have any news about fixing this bug? 
When do you expect that it will be possible to order categories in non-English wikies?
Thanks</pre>
    </div><div id="c56" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c56">Comment 56</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-08-24 14:18:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >No, it's a big change, no hurry on it.</pre>
    </div><div id="c57" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c57">Comment 57</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Stu Derby</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-09-07 17:22:35 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Could someone confirm that the current collation is still based on the UTF-8 encoding? The last reference to that is a couple years old. I'm particularly interested in the collation on en.wikipedia.org, if it matters. (Not a big deal, but someone is seriously arguing that Swedish collation is correct on the &quot;en&quot; site, in part because certain characters sort &quot;correctly&quot; by default).</pre>
    </div><div id="c58" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c58">Comment 58</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-09-08 18:57:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Nothing has changed. No &quot;Swedish&quot; collation is, or has ever, been used.

Binary sorting is used only.</pre>
    </div><div id="c59" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c59">Comment 59</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Shinjiman</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-09-13 09:20:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Please allow correct alphabetic order in Categories"
   href="show_bug.cgi?id=11322">Bug 11322</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c60" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c60">Comment 60</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Lejonel</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2007-10-01 08:47:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical order in tr.wikipedia"
   href="show_bug.cgi?id=11503">Bug 11503</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c61" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c61">Comment 61</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-08 06:30:34 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Created <span class=""><a href="attachment.cgi?id=4632" name="attach_4632" title="Thai sorting function See comment #61">attachment 4632</a> <a href="attachment.cgi?id=4632&amp;action=edit" title="Thai sorting function See comment #61">[details]</a></span>
Thai sorting function
See <a href="show_bug.cgi?id=164#c61">comment #61</a>

This zip archive contains comparing function for sorting Thai words.

Since Thai words cannot be sorted alphabetically under UTF-8 encoding, especially words lead with pre-vowel -- เ, แ, โ, ใ, ไ. Unicode treats these characters like binary so the words always show up at the end.

For example, we have a list: กา, เก, ขา, เข, คา. Sorting under Unicode will result กา, ขา, คา, เก, เข and it becomes 4 indexes of characters (ก, ข, ค, เ) which is not preferable. It should be กา, เก, ขา, เข, คา and should have only 3 indexes (ก, ข, ค). The fact is เ, แ, โ, ใ, ไ were vowels, not consonants. The consonant is located after it.

Secondly, all of tone symbols such as ก็ ก่ ก้ ก๊ ก๋ ก์ (seen as upper diacritics) were also treated as binary and on the same precedence as other consonants. This will result another case of incorrect alphabetical order.

For example, we have a list: กอ, ก่อ, ก้อ, กา, ก่า, ก้า. Sorting under Unicode will result กอ, กา, ก่อ, ก่า, ก้อ, ก้า which is totally wrong. Thai dictionaries commonly do not arrange tone symbol at first. It should be กอ, ก่อ, ก้อ, กา, ก่า, ก้า like I just presented before.

This function was released 15 years ago by a government agency but only few people keep an eye on it. Fortunately, I found this valuable function at <a href="http://tinyurl.com/ypot5n">http://tinyurl.com/ypot5n</a> (I must shorten the URL because it is too long) then I adapt into PHP and it wonderfully works.

You can directly test PHP scripts. I already demonstrate how to sort (which requires an array). For Unicode framework, please use &quot;thaisort_u8.php&quot; instead of another one.</pre>
    </div><div id="c62" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c62">Comment 62</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Arthit Suriyawongkul</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-09 08:53:06 UTC
        </span>
      </div>



<pre class="bz_comment_text" >reply to <a href="show_bug.cgi?id=164#c33">comment  #33</a> from Pablo Saratxaga

in that case (specific to MediaWiki installed on Wikimedia servers, for Wikimedia serving purpose, and not MediaWiki software in general), ICU4C/libicu also a good candidate,
as it supports wide range of locales/charsets, including locale data from Common Locale Data Repository (CLDR).
libicu now available in many popular Linux distros.

<a href="http://www.icu-project.org/">http://www.icu-project.org/</a>
</pre>
    </div><div id="c63" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c63">Comment 63</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Arthit Suriyawongkul</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-09 08:59:43 UTC
        </span>
      </div>



<pre class="bz_comment_text" >for MediaWiki software in general,
we might try this new PHP Internationalization extension (Intl), an ICU wrapper for PHP.
Matched to our interests, this extension support locale-sensitive collation (sorting),
and it can do normalization as well.

More features list and info can be found at:

<a href="http://docs.php.net/manual/en/intro.intl.php">http://docs.php.net/manual/en/intro.intl.php</a>

</pre>
    </div><div id="c64" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c64">Comment 64</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-09 11:30:02 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c63">comment #63</a>)
<span class="quote">&gt; for MediaWiki software in general,
&gt; we might try this new PHP Internationalization extension (Intl), an ICU wrapper
&gt; for PHP.</span >

You don’t want to sort in PHP code. You need the sorting to be done directly in the database. MySQL already has quite good support for locale-dependent sorting (collation), (AFAICT generally much better than what is in CLDR, see e.g. <a href="http://dev.mysql.com/doc/refman/6.0/en/charset-general.html">http://dev.mysql.com/doc/refman/6.0/en/charset-general.html</a>) however, MediaWiki (on Wikimedia sites; you can try to use it in your own wiki installation) does not use it.</pre>
    </div><div id="c65" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c65">Comment 65</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-10 06:46:29 UTC
        </span>
      </div>



<pre class="bz_comment_text" >From #61

Every language of Wikipedia uses UTF-8 encoded database so they cannot sort correctly on some language, especially Thai, and we cannot convert database encoding for just one locale (they will not able to store any useful Unicode characters). So I must present the function to sort after database does. Thai Wikipedia has had this problem since it was founded.</pre>
    </div><div id="c66" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c66">Comment 66</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-10 06:57:43 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Or another way, could anyone complain about this case and submit my file to the Unicode Consortium insead? Then we (as Thai people) will not worry about it anymore. :D</pre>
    </div><div id="c67" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c67">Comment 67</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-10 09:30:33 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c65">comment #65</a>)
<span class="quote">&gt; Every language of Wikipedia uses UTF-8 encoded database so they cannot sort
&gt; correctly on some language, especially Thai, and we cannot convert database
&gt; encoding for just one locale (they will not able to store any useful Unicode
&gt; characters). So I must present the function to sort after database does. Thai
&gt; Wikipedia has had this problem since it was founded.</span >

I am not sure I understand your objection. The character encoding and collation algorithm are two separate issues. There is no reason why a database could not be in UTF-8 and, at the same time, sort according to some complicated system. See <a href="http://dev.mysql.com/doc/refman/6.0/en/charset-unicode-sets.html">http://dev.mysql.com/doc/refman/6.0/en/charset-unicode-sets.html</a> for a list of currently supported collations with Unicode encoding in MySQL. Unfortunately, I don’t see Thai in there, so if you want to submit your code to somebody, it should be primarily MySQL. ;-)

(Note that e.g. the Czech collation is quite complicated, too, and it _is_ currently supported by MySQL with Unicode charset. For instance, Aaaaaaa sorts before Aáaaaaa, which sorts before Aaaaaab, i.e. you cannot sort in a single pass.)</pre>
    </div><div id="c68" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c68">Comment 68</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-11 01:46:58 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I think I understand your point. I might contact MySQL instead. The last question, how we can do with Thai Wikipedia? Is there somewhere to set collation separately (or in Mediawiki however)?</pre>
    </div><div id="c69" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c69">Comment 69</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-11 01:52:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*which is not to set at the database.</pre>
    </div><div id="c70" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c70">Comment 70</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-11 02:19:02 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If nowhere to set, I must present an optional variable such as &quot;$wgDBcollation&quot; to add collation literals through sql statement. See syntax to collate in MySQL web site. (Sorry if my posts annoy you. I can't edit comments like Mediawiki.)</pre>
    </div><div id="c71" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c71">Comment 71</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Octra Bond</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-11 02:26:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*Because the fact is one encoding may have more than one collation, like UTF-8 that Mormegil shows me.</pre>
    </div><div id="c72" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c72">Comment 72</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-11 20:25:35 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c68">comment #68</a>)
<span class="quote">&gt; Is there somewhere to set
&gt; collation separately (or in Mediawiki however)?</span >

Collation can be set at each table, or even column, so that this is “only” a task of altering the database structure a bit. The problem is that this has not really been tested with MediaWiki (AFAIAA), and there could be some problems, especially with non-BMP characters (characters above U+0FFFF), because of limited implementation of Unicode in MySQL (see e.g. <a href="http://bugs.mysql.com/bug.php?id=14052">http://bugs.mysql.com/bug.php?id=14052</a>). So that I doubt developers would be willing to make such switch on any Wikimedia wiki before much more work and testing would be done there.

I was considering trying and testing a partial interim solution at least for category sorting, where we have cl_sortkey, which is not used for much else besides sorting. So that there should no real problems switching this from BINARY sorting to some specified, which would be a good first step.

Another possibility of implementing this would be to have a copy of page_title column+index (and possibly dtto for some other tables), only with a defined collation and use this column for sorting instead of the original page_title. It would be easier if you could add just another index on the same column with another collation, but you can’t do that in MySQL, IIANM.

(On a sidenote, basic support for database-level Unicode has been in MediaWiki for quite some time, see <a href="http://www.mediawiki.org/wiki/Manual:$wgDBmysql5">http://www.mediawiki.org/wiki/Manual:$wgDBmysql5</a>, although it is still marked as “WARNING: THIS IS EXPERIMENTAL!” and not much work (and capabilities) has been put there since, AFAIK.)</pre>
    </div><div id="c73" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c73">Comment 73</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-13 00:24:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >A couple quick notes:

* Wikimedia currently runs MySQL 4.0, which has no native Unicode support.

* MySQL 4.1 and 5.x have not-quite-done UTF-8 support, which is insufficient for storage in the primary tables. In most cases this would be sufficient for a sorting-specific summary table (such as the titlekey table used in the TitleKey extension I whipped up)

* Collation affects not only sorting, but unique key restraints. This makes a MySQL-based collation unsuitable for the primary table fields, but again would be acceptable in a summary table used for sorting.

* Some sites are multilingual, which may make an ideal sort order rather difficult to manage. :)</pre>
    </div><div id="c74" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c74">Comment 74</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tisza Gergő</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-13 22:41:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" >So are we waiting still for Wikimedia to upgrade its MySQL servers? The solutions described in <a href="show_bug.cgi?id=164#c25">comment 25</a> and <a href="show_bug.cgi?id=164#c29">comment 29</a> (two and a half years ago...) look simple, and they would work with any database, without need for potentially breaking changes.</pre>
    </div><div id="c75" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c75">Comment 75</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-14 11:43:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c74">comment #74</a>)
<span class="quote">&gt; solutions described in <a href="show_bug.cgi?id=164#c25">comment 25</a> and <a href="show_bug.cgi?id=164#c29">comment 29</a> (two and a half years ago...)
&gt; look simple, and they would work with any database</span >

The solution in <a href="show_bug.cgi?id=164#c25">comment 25</a> is not general enough. As I mentioned above, Czech sorting cannot be done in one step, so that you would have to keep _two_ sort keys (and sort on the tuple (key1, key2)), and the older version of the Czech sorting standard required _three_ steps (it has been simplified in the last revision). I have no idea what strange sorting systems are there… Not to mention that we would need to develop our own collation algorithms (That is far from “simple” as you write!), when we have better things to do… (NIH, anyone?)

The <a href="show_bug.cgi?id=164#c29">comment 29</a> ''could'' be a bit better than the current solution (although it is only an interim solution), although some people might disagree even with that, I guess.</pre>
    </div><div id="c76" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c76">Comment 76</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tisza Gergő</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-14 12:53:03 UTC
        </span>
      </div>



<pre class="bz_comment_text" >For multipass sorting you just need to generate a key for each pass, and join them together with a space (which is the first character of the ASCII and Unicode alphabet apart from control characters). But most of the time you don't even need that, just transform the word to lowercase, strip out all the accents that don't matter in the first pass, and the words with equal keys will be ordered based on their original names, which is usually just what the second pass would do. For example see here a simple character mapping based sortkey for Hungarian (which also has a two-pass, aaa &lt; aáa &lt; aab sort order): <a href="http://translatewiki.net/wiki/Support#section-2fce6e673f06ad27330b562f8836a458">http://translatewiki.net/wiki/Support#section-2fce6e673f06ad27330b562f8836a458</a>

Number sorting (<a class="bz_bug_link 
          bz_status_REOPENED "
   title="REOPENED - Natural number sorting in category listings"
   href="show_bug.cgi?id=6948">bug 6948</a>) can also be handled this way, for example by adding a larger-than-digits character to every digit-nondigit boundary.</pre>
    </div><div id="c77" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c77">Comment 77</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Li-sung</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-02-21 15:00:11 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Words beginning with ө, ү, and ё"
   href="show_bug.cgi?id=13093">Bug 13093</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c78" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c78">Comment 78</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-04-28 11:01:03 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c33">comment #33</a>)
<span class="quote">&gt; As GNU/Linux operating system is being used on the wikipedia
&gt; servers; then a possible solution would be to delegate the
&gt; alphabetical string sorting to the the system (glibc and locales); there already
&gt; are correct LC_COLLATE defintions
&gt; for glibc for almost all languages that have a quite good
&gt; number of articles; and for those that don't have yet (or the
&gt; languages still to grow) an LC_COLLATE definition could be
&gt; easily writen and installed.
&gt; I can help with that if needed (I work for Mandriva and part
&gt; of my work is actually checking and testing the locales, and
&gt; write new ones for whatever new language we are requested
&gt; support for; I've already corrected or written from scratch
&gt; various glibc sorting order definitions already) </span >

1. MediaWiki category sorting does currently depend on MySQL sort function.
   According to, &quot;includes/CategoryPage.php&quot;,

&lt;pre&gt;&lt;nowiki&gt;
		$res = $dbr-&gt;select(
			array( 'page', 'categorylinks' ),
			array( 'page_title', 'page_namespace', 'page_len', 'page_is_redirect', 'cl_sortkey' ),
			array( $pageCondition,
			       'cl_from          =  page_id',
			       'cl_to'           =&gt; $this-&gt;title-&gt;getDBKey()),
			       #'page_is_redirect' =&gt; 0),
			#+ $pageCondition,
			__METHOD__,
			array( 'ORDER BY' =&gt; $this-&gt;flip ? 'cl_sortkey DESC' : 'cl_sortkey',
			       'USE INDEX' =&gt; 'cl_sortkey', 
			       'LIMIT'    =&gt; $this-&gt;limit + 1 ) );
&lt;/nowiki&gt;&lt;/pre&gt;

   which will query sql like this,

&lt;pre&gt;&lt;nowiki&gt;
      SELECT  page_title,page_namespace,page_len,page_is_redirect,cl_sortkey  FROM `page`,`categorylinks` FORCE INDEX (cl_sortkey) WHERE (cl_sortkey &gt;= 'my begin page name') AND (cl_from = page_id) AND cl_to = 'my category name'  ORDER BY cl_sortkey LIMIT 201
&lt;/nowiki&gt;&lt;/pre&gt;

   This will have advantage in that, php doesn't need to fetch all page title (for that category) from database.  It just fetch only the titles needed to appear in current displaying page.


2. From my experiment in Ubuntu GNU/Linux, setting LC_ALL or LC_COLLATE doesn't affect php5 sort() function.

&lt;pre&gt;&lt;nowiki&gt;
$ LC_ALL=C php5 -r '$a = array(&quot;a&quot;, &quot;b&quot;, &quot;A&quot;, &quot;B&quot;); sort($a, SORT_LOCALE_STRING|SORT_STRING); foreach ($a as $b) { print &quot;$b\n&quot;; }'
A
B
a
b
$ LC_ALL=en_US php5 -r '$a = array(&quot;a&quot;, &quot;b&quot;, &quot;A&quot;, &quot;B&quot;); sort($a, SORT_LOCALE_STRING|SORT_STRING); foreach ($a as $b) { print &quot;$b\n&quot;; }'
A
B
a
b
$ LC_COLLATE=en_US php5 -r '$a = array(&quot;a&quot;, &quot;b&quot;, &quot;A&quot;, &quot;B&quot;); sort($a, SORT_LOCALE_STRING|SORT_STRING); foreach ($a as $b) { print &quot;$b\n&quot;; }'
A
B
a
b
&lt;/nowiki&gt;&lt;/pre&gt;

   While it work in &quot;sort&quot; program,
&lt;pre&gt;&lt;nowiki&gt;
$ (echo a; echo b; echo A; echo B) | LC_ALL=C sort
A
B
a
b
$ (echo a; echo b; echo A; echo B) | LC_ALL=en_US sort
a
A
b
B
$ (echo a; echo b; echo A; echo B) | LC_COLLATE=en_US sort
a
A
b
B
&lt;/nowiki&gt;&lt;/pre&gt;
</pre>
    </div><div id="c79" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c79">Comment 79</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-05-09 14:28:27 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c21">comment #21</a>)
<span class="quote">&gt; 1) MediaWiki has no support for collations currently.
&gt; 2) MySQL's UTF-8 support doesn't support 4-byte characters, according to MySQL docs. It's unknown whether this will cause data 
&gt; corruption for some pages and needs to be investigated.
&gt; 3) It's unknown at this time whether we can make use of collations for sorting without that also infecting equality checks (and 
&gt; unique indexes).
&gt; 4) If 3), the affects of this for creating page name conflicts and other issues is unknown.</span >

1. You can set default collation of the table to &quot;utf8_bin&quot;, so its won't infect equality checks.

2. The category sorting can be selected by passing collation via cgi variable, for example,

   <a href="http://.../wiki/Category:Abc?collation=czech_ci">http://.../wiki/Category:Abc?collation=czech_ci</a>

2.1 The mysql query will look like,

   mysql&gt; SELECT ... ORDER BY cl_sortkey COLLATE utf8_czech_ci LIMIT 201

2.2 The collation may also be set in Special:Preferences.
2.3 The drop down list for all available collations in Special:Preferences will depend on the database.
    In MySQL 5.x, MediaWiki will query the following command the get the available collations,

   mysql&gt; show collation like 'utf8_%';

<span class="quote">&gt; 5) MySQL may or may not have sufficient collation options.
&gt; 6) We may want this option without requiring particular versions of MySQL.
&gt; </span >

There's no way to not depend on MySQL sorting, which depend on the versions of MySQL.
By not depend on database sorting, MediaWiki will need to fetch all page title
(for that category) from database.

With my solution, it just let the available collations to depend on the database engine.
</pre>
    </div><div id="c80" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c80">Comment 80</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-05-09 16:24:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If the indexed field doesn't have collation specified, that sorting is going to be done as a filesort -- fetching the entire potentially matching data set, sorting it in a temporary table, and then returning results in order *every time a request is made*.

That's obviously not going to be suitable.</pre>
    </div><div id="c81" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c81">Comment 81</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-05-12 05:24:11 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c80">comment #80</a>)
<span class="quote">&gt; If the indexed field doesn't have collation specified, that sorting is going to
&gt; be done as a filesort -- fetching the entire potentially matching data set,
&gt; sorting it in a temporary table, and then returning results in order *every
&gt; time a request is made*.</span >

Do you mean that,

1. select ... order by ... collate utf8_czech_ci limit 201;
2. select ... order by ... collate utf8_bin limit 201;

You mean that 1 will slower than 2, if the default collation is utf8_bin?
You mean that 1 will need to do something in temporary table, if it sort using the non-default collation?

<span class="quote">&gt; 
&gt; That's obviously not going to be suitable.
&gt; </span >
</pre>
    </div><div id="c82" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c82">Comment 82</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-05-12 11:20:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I've just summarized all ideas from this discussion in, <a href="http://www.mediawiki.org/wiki/Bugzilla/164">http://www.mediawiki.org/wiki/Bugzilla/164</a>

Please update your ideas there.
</pre>
    </div><div id="c83" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c83">Comment 83</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-05-12 11:27:20 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I've just summarized all ideas from this discussion in, <a href="http://www.mediawiki.org/wiki/Bugzilla/164">http://www.mediawiki.org/wiki/Bugzilla/164</a>

Please update your ideas there.
</pre>
    </div><div id="c84" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c84">Comment 84</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Lars Aronsson</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-09-07 16:04:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" >According to the reference manual, MySQL 6.0 introduces
support for supplementary Unicode characters.
Would that be a solution to this old bug?

MySQL 6.0 is still under development, so it might not
be mature for Wikimedia servers yet. But waiting for
it to become stable might be smarter than developing
an advanced work-around.

Or is the new functionality in MySQL 6.0 still
insufficient, so we will need the work-around anyway?</pre>
    </div><div id="c85" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c85">Comment 85</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-09-08 08:05:34 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c84">comment #84</a>)
<span class="quote">&gt; MySQL 6.0 is still under development, so it might not
&gt; be mature for Wikimedia servers yet. But waiting for
&gt; it to become stable might be smarter than developing
&gt; an advanced work-around.</span >

Note that currently, Wikimedia servers still run on MySQL 4.0, even though the current GA release is 5.0. I wouldn’t hold my breath waiting for 6.0… (But yes, I agree that it is not too smart trying to implement our own collation (etc.) in PHP, when that is obviously a DBMS’s job.)</pre>
    </div><div id="c86" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c86">Comment 86</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-09-08 12:02:40 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c85">comment #85</a>)
<span class="quote">&gt; 
&gt; Note that currently, Wikimedia servers still run on MySQL 4.0, even though the
&gt; current GA release is 5.0. I wouldn’t hold my breath waiting for 6.0… (But</span >

We could implement this as an optional feature, for those who are using mysql 6.0.
This optional feature will enable any mediawiki server (other than Wikimedia servers) with mysql 6.0, to have the correct sorting order.

<span class="quote">&gt; yes, I agree that it is not too smart trying to implement our own collation
&gt; (etc.) in PHP, when that is obviously a DBMS’s job.)
&gt; </span >
</pre>
    </div><div id="c87" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c87">Comment 87</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tisza Gergő</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-09-08 20:25:23 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c84">comment #84</a>)
<span class="quote">&gt; But waiting for
&gt; it to become stable might be smarter than developing
&gt; an advanced work-around.</span >

Why wait for years when there is a clean temporary solution which is reasonably easy to implement, has no extra resource cost (category sorting is already done by custom sortkeys), and can be easily undone if neccessary? Besides, there is already a work-around: people DEAULTSORT directives in articles (in languages that use non-ASCII letters often, that means pretty much sorting every single page by hand). This is a huge waste of editor time which could be put to much better use, and it would be similarly difficult to remove the manual sortkeys if a superior software solution appeared. Allowing language-specific algorithms to define default sortkeys would be better then the current situation in every single aspect.
</pre>
    </div><div id="c88" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c88">Comment 88</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2008-10-20 17:10:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >UCA collation keys is really the solution; a pseudo-UCA-like system is currently used in French Wikitionary:

In almost all articles that contain any other characters that lowercase ASCII letters or space, we have inserted {{clé de tri}}, with an optional parameter (by default this parameter takes the article name itself). This template uses {{DEFAULTSORT:}} but computes itself the sortkey.

When the parameter is used, it must specifiy the article name without diacritics (but the original capitalization of the article title must be kept: it is implicitly converted to lowercase when computing internally the primary collation key. The parameter, when it is used should contain only base letters (but not necessarily ASCII, because it could also be Greek or Cyrillic base letters, or Hebrew, Arabic, Chinese...); it should contain no diacritic, no controls like joiners, apostrophes and ignorables removed, and all separators and punctuation converted to a single space. It can contain base digits (also without diacritics, and non-decimal digits shuold be converted to decimal digits appropriate for the language, e.g. the Roman VIII digit character should be rewritten using Latin letters).

If letters are ligatures, the parameter 1 must be specified with the letters separated withoutthe ligature (for the French article name &quot;œuf&quot;, the secondary key to specify in parameter 1 is &quot;oeuf&quot;, so that it sorts at letter &quot;o&quot;).

For the Catalan middle dot diacritic (that can only follow a letter l), it should be removed from the secondary key, treated as an ignorable, even though it is also a punctuation; this is not much a problem for most articles: only for the article related to the punctuation itself, you can keep it withut relpacing it by a space or removing it). Some intelligence must be taken into accoutn for such specific cases (but don't forget that Wiktionnary is built to contain words in many languages, but they will still be sorted according to the Wiktionnary's home language, here French).

If there are any other characters than letters, digits or spaces, the parameter MUST be specified, otherwise the indexing key will not be computed correctly.
If there are only plain letters, spaces, or digits, but some letters are capitals, the template {{clé de tri}} (which means &quot;sort key&quot; in French) MUST be used any way, even if it takes no parameter, because the indexing key will be computed correctly to take into account the case differences.

Then the index key is computed like this:
* compute the primary key : the parameter 1 (or its default, the article name) converted to lowercase.
* the secondary key is the parameter 1 (or its default, the article name): its use is to sort while still taking the case differences into account (note that ideally, this secondary key should be the parameter 1 written in reverse order from end to beginning to better match the French sort order, but there's still no function in Mediawiki to reverse a string).
* the third-level key is the unfiltered article name, it is used to sort while taking into account other differences: diacritics, differences of punctuation.
* The 3 keys are then concatenated, separated by &quot; !&quot; (a space followed by an exclamation point; ideally it should be a control soft as SOH=U+0001, however MediaWiki does not like this very much and generates garbage in the key that completely breaks the sort. The choice of &quot; !&quot; works correctly for that.

However:
(1) when the secondary key equals the primary key, it is replaced by an empty string: this occurs when the article name only use lowercase letters, or letters in a monocameral script: &quot;a !a !à&quot; becomes really &quot;a ! !à&quot;, without the secondary key &quot;a&quot; (which had to be given explicitly in parameter 1 for the full article name &quot;à&quot;)
(2) when the third-level key equals the secondary key, it is replaced by an empty string: this occurs when the default value of parameter 1 is used, i.e. it is the article name itself (when the artcile name contains no diacritics and no punctuation or ignorable characters): &quot;a !A !A&quot; becomes really  just &quot;a ! A !&quot; without the third level key (i.e. the full article name &quot;A&quot; here)
(3) key separators at end are dropped: &quot;a !a !a&quot; becomes really &quot;a ! !&quot; according to rules (1) and (2), but then just &quot;a&quot; according to rule three: this means that all lowercase or monocameral article names without diacritics or punctuation but just spaces have the shortest keys.

You'll note immediately that with articles whose titles only differ by case, the sort key for the articles with capitals is longer than the name without capitals. It's not perfect, but it works most of the time (and it is sufficient to sort the French Wiktionnary).

Then Mediawiki is building its own indexing keys from the keys supplied: if they are too long for its internal limits, they are truncated and MediaWiki appends &quot;__UNIQUE__&quot; followed apparently by the revision id or some magic number (if truncation occurs, not all levels will be used, but anyway, at least the sort will work to group a small number of articles in the same displayed page, with just minor sort problems...

I am still not satisfied by the way the secondary key and ternary key are generated: they are too long. Using full UCA (tailored to take into account the language order), we could dramatically reduce their length.

Also we could sort in traditional order for other languages that use digrams or trigrams or whose letters are not ordered in the binary order, such as letters that are foreign to that language and that are placed at end of their reduced alphabet (but note the problem with those letters or digrams, you would have to remap them after letter &quot;z&quot; to get a significant chracter usable as the prefix for sort groups displayed in the lsit or used in the &quot;from=&quot; parameter of categories. This is not a problem for French, including for its two orthographic ligatures &quot;œ&quot; and &quot;æ&quot; (the first one is not frequent but still present in widely used words, the second one is used only in some scientific, medical, or juridic terms, whose origin comes from Latin).

In the French wiktionnary, this works remarkably well to have categories that are correctly ordered and meet user expectation (with just minor sort quirks: you can still find the searched entries just within a very small distance of search while navigating the categories with lots of articles, notably the categories per language that are supposed to index ALL words and expressions used in a language): you can effectively search from some letters (yu just have to type them in lowercase only, however the search form in categories will not enforce it).

Look also in the French Wikitionnary to see what is happening in this system for sorting the &quot;russe&quot; category for the Russian language (using cyrillic), or &quot;bulgare&quot;, or hebrew (yes, it works quite well for words that contain hebrew points), or &quot;grec&quot;, look at &quot;polonais&quot; to see how Polish words are sorted (We are still looking at corercting the articles where {{clé de tri}} has not been specified where it should).

Note that categories that are populated with both article names and subcategories, the subcategories should not be indexed using {{clé de tri}} but using {{DEFAULTSORT:}} directly (where you'll specify a key starting by a capital, so that all subcategories will be in the head of the list, before all other the articles that you'll navigate with &quot;next 200&quot; or &quot;previous 200&quot;.)

This solution is exploitable too in Wikipedia (however Wikipedia does not keep the initial lowercase letters and forces their capitalization.

All this work should be automatable without having to use {{clé de tri}} and figuring out how to specifu the secondary key. It would be great if MediaWiki used such algorithm by default (i.e. in absence of {{DEFAULTSORT:}} and of any explicit key in &quot;[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3Aname">category:name</a>|key]]&quot; (just &quot;[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3Aname">category:name</a>]]&quot;.

Then it's up to Mediawiki to determine its maximum key length from such algorithm and truncate keys where appropriate to follow them with the &quot;__UNIQUE__id&quot; (which is visible in the &quot;previous 200&quot; and &quot;next 200&quot; links) (It would also be preferable that the unique id, becomes a separate key for the indexing and for the navigation with next/previous 200)
</pre>
    </div><div id="c89" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c89">Comment 89</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philip Tzou</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-01-13 11:54:13 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Created <span class=""><a href="attachment.cgi?id=5669" name="attach_5669" title="sorting orders patch for Chinese language">attachment 5669</a> <a href="attachment.cgi?id=5669&amp;action=edit" title="sorting orders patch for Chinese language">[details]</a></span>
sorting orders patch for Chinese language

This patch can provide pinyin, strokes and bopomofo sorting orders for MediaWiki in Chinese language. However, sorting orders of other languages can be created and customised easily by inheriting related functions defined in Language.php, then use &quot;update.php&quot; to update your mysql database.</pre>
    </div><div id="c90" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c90">Comment 90</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Happy-melon</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-06-15 20:33:20 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Capital letters are always sorted first"
   href="show_bug.cgi?id=19197">Bug 19197</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c91" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c91">Comment 91</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Chad H.</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-06-18 15:49:56 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Special:PrefixIndex and Special:AllPages have wrong ordering"
   href="show_bug.cgi?id=19279">Bug 19279</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c92" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c92">Comment 92</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-06-18 20:26:14 UTC
        </span>
      </div>



<pre class="bz_comment_text" >With <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Special:PrefixIndex and Special:AllPages have wrong ordering"
   href="show_bug.cgi?id=19279">bug 19279</a> being marked as a duplicate of this, I'm wondering what's the state of play on the (perhaps more specific) issue of the ordering of pages in English Wikipedia - on Special:PrefixIndex for example (where we have the totally counter-intuitive ordering Z - space - a. This bug looks to have been kicking around for five years - is there a solution, or at least partial one, in the pipeline? (Perhaps based on whatever it is that generates case-insensitive lists for type-ahead in the search box.)</pre>
    </div><div id="c93" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c93">Comment 93</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Michael Zajac</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-06-18 23:51:14 UTC
        </span>
      </div>



<pre class="bz_comment_text" >It's even more embarrassing in Wiktionary.  Who wants a dictionary that doesn't list words in alphabetical order?  Over there, some editors have been routing around WikiMedia limitations by building index pages with other tools 

  <a href="http://en.wiktionary.org/wiki/Index:English/a1">http://en.wiktionary.org/wiki/Index:English/a1</a></pre>
    </div><div id="c94" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c94">Comment 94</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Jean-Sébastien Girard</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-06-23 21:29:49 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I've just realised that for any given page in French in en:wikt that has one or more accent (and that is not counting capitals that often needs to be discounted), you need to add a sortkey for every single template that categorise: etymology templates, topical templates, part-of-speech templates etc. etc. You CANNOT use a defaultsort on the off chance another clsoely related language will need a different sorting! It's just ridiculous and start running in the 5+ pointless bits of code very fast.

People complain that Wikipedia pages are complicated to edit? Ah! Come to Wiktionary and get your ass whipped!</pre>
    </div><div id="c95" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c95">Comment 95</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Shinjiman</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-07-08 18:36:24 UTC
        </span>
      </div>



<pre class="bz_comment_text" >There are some data that might be useful in the CLDR from Unicode.org, it might be a good resource to producing the way that are collated.</pre>
    </div><div id="c96" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c96">Comment 96</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-07-20 03:53:08 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - 'edit watchlist' sorting issue, plus bonus complaint"
   href="show_bug.cgi?id=18599">Bug 18599</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c97" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c97">Comment 97</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Niklas Laxström</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-07-28 13:12:12 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical ordering in Turkmen language"
   href="show_bug.cgi?id=19967">Bug 19967</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c98" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c98">Comment 98</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Chad H.</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-07-30 23:29:58 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Add sort key to entries in Special:Specialpages"
   href="show_bug.cgi?id=17260">Bug 17260</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c99" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c99">Comment 99</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ihar Mahaniok</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-01 15:11:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Hi,

Philip, what's the status of it?

I've asked around, and the most straightforward and the best way to address this seems to use ICU library at <a href="http://icu-project.org/">http://icu-project.org/</a>. It will auto-magically give correct sorting for all (or most) of the world languages.

It would be nice to know what are the hurdles or obstacles or where I can help with getting this implemented.</pre>
    </div><div id="c100" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c100">Comment 100</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-02 04:55:09 UTC
        </span>
      </div>



<pre class="bz_comment_text" >#88, Does UCA explicitly specify the binary representation of the generated key?

#99,
<a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Drawback_3">http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Drawback_3</a>
Could anyone confirm, if libicu provide an api to generate the binary representation of the collation key?
</pre>
    </div><div id="c101" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c101">Comment 101</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Ihar Mahaniok</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-02 15:32:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >#100, apparently, yes. see <a href="http://bugs.icu-project.org/apiref/icu4c/classCollationKey.html">http://bugs.icu-project.org/apiref/icu4c/classCollationKey.html</a>. But I don't have direct experience with this.</pre>
    </div><div id="c102" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c102">Comment 102</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-03 06:52:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c101">comment #101</a>)
<span class="quote">&gt; #100, apparently, yes. see
&gt; <a href="http://bugs.icu-project.org/apiref/icu4c/classCollationKey.html">http://bugs.icu-project.org/apiref/icu4c/classCollationKey.html</a>. But I don't
&gt; have direct experience with this.
&gt; </span >

Thanks a lot.
Hmm, but seems that this class is deprecated in ICU 2.8, and they recommend to use Collator::getSortKey instead,

<a href="http://bugs.icu-project.org/apiref/icu4c/classCollator.html#e524fd43a06d4429e2c76bef35874d4c">http://bugs.icu-project.org/apiref/icu4c/classCollator.html#e524fd43a06d4429e2c76bef35874d4c</a>
</pre>
    </div><div id="c103" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c103">Comment 103</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-03 08:24:34 UTC
        </span>
      </div>



<pre class="bz_comment_text" >In case, we are going to use Collator::getSortKey(), the problem will be that,
php-intl seem to not yet implement the direct interface to getSortKey(),
<a href="http://docs.php.net/manual/en/collator.sortwithsortkeys.php">http://docs.php.net/manual/en/collator.sortwithsortkeys.php</a>
:(

Should we first file this bug to php-intl?
</pre>
    </div><div id="c104" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c104">Comment 104</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-03 08:54:27 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c103">comment #103</a>)
<span class="quote">&gt; In case, we are going to use Collator::getSortKey(), the problem will be that,
&gt; php-intl seem to not yet implement the direct interface to getSortKey(),
&gt; <a href="http://docs.php.net/manual/en/collator.sortwithsortkeys.php">http://docs.php.net/manual/en/collator.sortwithsortkeys.php</a>
&gt; :(
&gt; 
&gt; Should we first file this bug to php-intl?
&gt; </span >

<a href="http://pecl.php.net/bugs/bug.php?id=16831">http://pecl.php.net/bugs/bug.php?id=16831</a>
</pre>
    </div><div id="c105" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c105">Comment 105</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Alexandre Emsenhuber [IAlex]</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-09 12:06:27 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetical ordering in Turkmen language"
   href="show_bug.cgi?id=19967">Bug 19967</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c106" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c106">Comment 106</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-18 11:32:43 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c3">comment #3</a>)
<span class="quote">&gt; Just a note: English sort order is not used, but rather the raw order of the
&gt; characters as they appear in Unicode.
&gt; 
&gt; MySQL's collation options are useless as they are server-wide and (through
&gt; 4.0.x) don't support Unicode. We likely need to add a sort key field that 
&gt; we generate ourselves, appropriate for each language.
&gt; 
&gt; Probably relevant: <a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>
&gt; </span >

Brion, what method are we going to implement for key genration?

There are 2 interesting approaches in,
<a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Proposed_solution_3">http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Proposed_solution_3</a>
* implement the direct C/C++ interface to ICU4C/libicu's Collator::getSortKey() in mediawiki
* use php-intl, for key generation (waiting for <a href="http://pecl.php.net/bugs/bug.php?id=16831">http://pecl.php.net/bugs/bug.php?id=16831</a> to be resolved)

Each approach has its own drawback,
<a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Drawback_3">http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Drawback_3</a>
* The first approach will make the mediawiki installation to be architecture dependent.  It also introduce an additional dependency (libicu) of mediawiki installation.
* The second approach introduces more dependencies (php-intl extension and libicu) of mediawiki installation.

Which one does you prefer?
</pre>
    </div><div id="c107" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c107">Comment 107</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 05:03:14 UTC
        </span>
      </div>



<pre class="bz_comment_text" >The key generation module may be implemented as an extension, so that the core mediawiki installtion will not be architecture dependent nor require additional dependency.

This extension will just do the task of key generation, mediawiki core will then put the generated key in the field categorylinks.cl_sortkey.
It also need the script maintenance/updateSortkey.php to be invoked when this extension is added or removed.

How do you think about this idea?
</pre>
    </div><div id="c108" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c108">Comment 108</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 08:53:12 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c107">comment #107</a>)
<span class="quote">&gt; The key generation module may be implemented as an extension, so that the core
&gt; mediawiki installtion will not be architecture dependent nor require additional
&gt; dependency.
&gt; 
&gt; This extension will just do the task of key generation, mediawiki core will
&gt; then put the generated key in the field categorylinks.cl_sortkey.
&gt; It also need the script maintenance/updateSortkey.php to be invoked when this
&gt; extension is added or removed.
&gt; 
&gt; How do you think about this idea?
&gt; </span >

Hmm, we cannot store this generated key in categorylinks.cl_sortkey, since the firstChar() of the original key is needed in rendering the Category pages.

Seems that, we really need to add additional field in table categorylinks.
</pre>
    </div><div id="c109" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c109">Comment 109</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 09:18:36 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that, an extension that generates the sort key should also provide the firstChar() interface.

In some languages, when the sorting is implemented, the behavior of firstChar() must be properly handled.

See: <a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#firstChar.28.29">http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#firstChar.28.29</a>
</pre>
    </div><div id="c110" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c110">Comment 110</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 10:38:58 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I find it rather disheartening that this very simple thing has not been solved after so many years (how is it conceivable that software designed for encyclopedias and dicionaries can't even get alphabetical order right?)

Here's how I would do it (this is all just abstract thought): have a new column in the table of pages, to contain a unique key: X__Y, where Y is the page title, and X is some language-dependent function of Y which represents Y alphabetically. For example, for English, the function would convert all letters to the same case, convert modified letters (diacritics and so on) to their basic unmodified form, strip out most punctuation, probably strip out spaces too (though there are alternative approaches to spaces).

Then alphabetical indexing of the table (sorry, don't know exactly what I mean, but whatever is used to generate the contents lists at Special:PrefixIndex/AllPages) would be based on this new column, not on the page title itself, and the value in this column would also be passed as the category sort key. This way you solve two problems at once - the contents lists and the categories (the preceding suggestions seem to relate to the categories only). AND it can probably be leveraged to improve search/Go (to avoid the need to create redirects to titles with diacritics and so on).

Don't know if this is any use, but anyway, I hope someone can get these very basic issues solved soon.</pre>
    </div><div id="c111" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c111">Comment 111</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 12:56:55 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c110">comment #110</a>)
<span class="quote">&gt; 
&gt; Here's how I would do it (this is all just abstract thought): have a new column
&gt; in the table of pages, to contain a unique key: X__Y, where Y is the page
&gt; title, and X is some language-dependent function of Y which represents Y
&gt; alphabetically. For example, for English, the function would convert all
&gt; letters to the same case, convert modified letters (diacritics and so on) to
&gt; their basic unmodified form, strip out most punctuation, probably strip out
&gt; spaces too (though there are alternative approaches to spaces).
&gt; 
&gt; Then alphabetical indexing of the table (sorry, don't know exactly what I mean,
&gt; but whatever is used to generate the contents lists at
&gt; Special:PrefixIndex/AllPages) would be based on this new column, not on the
&gt; page title itself, and the value in this column would also be passed as the
&gt; category sort key. This way you solve two problems at once - the contents lists
&gt; and the categories (the preceding suggestions seem to relate to the categories</span >

Storing the sort key in table of pages does not solve the categories case, since the category sort key for each page can be customized to be different from the page's title, like this,

[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3AMy%20Category">Category:My Category</a>|My customized key]]

<span class="quote">&gt; only). AND it can probably be leveraged to improve search/Go (to avoid the need
&gt; to create redirects to titles with diacritics and so on).
&gt; </span >
</pre>
    </div><div id="c112" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c112">Comment 112</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 15:28:35 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Yes, obviously customized keys would still override the stored ones - is there any problem associated with this? (I suppose a similar language-dependent function would have to be applied to customized sort keys as well, to ensure their comparability with the ones from the table, and there might be changeover issues.)</pre>
    </div><div id="c113" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c113">Comment 113</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-23 16:44:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c112">comment #112</a>)
<span class="quote">&gt; Yes, obviously customized keys would still override the stored ones - is there
&gt; any problem associated with this?</span >

But the customized keys are in the page ↔ category relationship, not on the page itself, i.e. one page can have more than one sort key, e.g.:

 [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3ALists">Category:Lists</a>|Foo]]
 [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3AFoo">Category:Foo</a>|*List of foos]]

So that your point that you would create a new column “in the table of pages”, is not a sufficient solution. But (no offense!) I don’t think your idea adds anything new to this discussion. All this has been debated thoroughly, only minor details seem to remain, plus that simple matter of programming…</pre>
    </div><div id="c114" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c114">Comment 114</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-24 00:24:15 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Yes both the page titles and the custom sort keys are going to need collation keys.

Ugly or confusing naming could result.

Collation keys are intended for efficient binary comparison and are not guaranteed to be human readable text, therefore they cannot be used for what we already call custom category sort keys. And since the custom category sort keys have to collate into correct sequence with plain old page titles they both need to use the same kind of binary collation key.
</pre>
    </div><div id="c115" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c115">Comment 115</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-24 07:51:20 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Special:PrefixIndex and Special:AllPages have wrong ordering"
   href="show_bug.cgi?id=19279">Bug 19279</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c116" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c116">Comment 116</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-24 08:13:00 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Umm, technically, seem that, this bug has been heavily focused on collation only in category pages.
However, the <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Special:PrefixIndex and Special:AllPages have wrong ordering"
   href="show_bug.cgi?id=19279">Bug 19279</a> (as reported by Le Chat), is about collation of the page title which is employed in Special:PrefixIndex and Special:AllPages, but it is also marked as a duplicate of this bug.

Should we deduplicate them?

As the collation in PrefixIndex/AllPages has not been thoroughly discussed,
could we solve category pages first, and leave the PrefixIndex/AllPages to be resolved later?
Leaving categories and PrefixIndex to have different collation is still make sense?

I think it make sense, since wikipedia in some languages has thoroughly fixed the collation in category pages by using the custom sort key, so its collation is currently different to the PrefixIndex.
</pre>
    </div><div id="c117" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c117">Comment 117</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-24 08:36:15 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If two birds can be killed with one stone, then let's take aim. Of course there's a workaround for categories with the sort keys, and sort keys will continue to have other uses (and thus require supporting) even if this bug is fixed. However there is no workaround for PrefixIndex, so that should be worked on with greater urgency, but clearly the same solution could be leveraged to make categories work more intuitively too. And it will potentially have other uses as well, such as making &quot;Go&quot; work without redirects in many cases. Is it maybe time to stop talking about this and for someone who knows what they're doing just to write the code? </pre>
    </div><div id="c118" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c118">Comment 118</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anon Sricharoenchai</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-24 11:13:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c117">comment #117</a>)
<span class="quote">&gt; uses as well, such as making &quot;Go&quot; work without redirects in many cases. Is it
&gt; maybe time to stop talking about this and for someone who knows what they're
&gt; doing just to write the code? 
&gt; </span >

Writing the code is easy, I think the pending work is to choose the solutions among these,

<a href="http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Proposed_solution_3">http://www.mediawiki.org/wiki/Bugzilla/collation_by_locale#Proposed_solution_3</a>

When a final solution is picked, the coding can then be started.
</pre>
    </div><div id="c119" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c119">Comment 119</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-29 06:31:02 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I think that you should first implement it in two steps:

== STEP ONE ==

First create a function that computes a collation key from a given string within a given locale, and provide it as a string function, something like {{#collate:locale|string}}

* e.g. &quot;{{#collate:fr|Clé}}&quot; could return something like &quot;cle !élc !Clé&quot;, using the &quot; !&quot; substring as a separator between collation elements in each level : note that here the secondary key is inverted, as specified in French.

* The exact collation keys should be made readable by taking, at each collation level, the first character that is part of the same collation group (at a given level).

* If you can find a more compact way to represent collation keys, you could as well accept the TAB character (instead of space+first non-space character) as the collation level separator, if the database will accept to store it and display it, however it will be difficult to use such key within prefix searches and in links, even if they are {{urlencode:d}}.

* This will allow Wiktionnaries to compute collation keys more reliably, but will still also allow using those strings for populating differrently the sort key for specific categories. The locale parameter can just be the language identifier: at least those languages already supported in WikiMedia projects, for which we can at least bind them to a default collation order appropriate for their scripts.

* The collation key computed should only use 3 levels (the fourth one is the string itself in its binary Unicode form, and is implicitly handled, it does not need to be specified or stored).
** Most of the time, the primary level will be readable as if it was using a very simplified script, with ignorable and diacritics characters dropped as well as apostrophes, other separators chanded to a single space, and all characters in lowercase.
** The most complex substring will be that for the secondary level : this is the one that cannot be computed easily today, it should not preserve the case differences and ignorable characters, the differences of accents should be in it (and the one that the French Wiktionnary requests as a parameter for its template &quot;[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Mod%C3%A8le%3Acl%C3%A9%20de%20tri">Modèle:clé de tri</a>]], but in fact it requests it with its original case, and then generates the secondary key by converting it to lowercase, but uses it directly as the third-level key).
** Most of the time the third level will be very similar to the original string (with its significant case), with just the ignorable characters removed.

* Some considerations should be done for languages with complex scripts: the primary key should at least be able to extract a meaningful first character usable when rendering categories : an initial Hangul syllable can be decomposed to its initial jamo, Chinese ideographs should be mapped to a radical/strokes mapping, so that the radical can be used as the first &quot;character&quot;. The Unicode's Unihan database can be helpful.

* For locales that use contractions, the &quot;first&quot; character in a collation group may be a digram or trigram : displayin the content of a category sorted this way should be able to use that digram/trigram as the title, instead of just the first physical Unicode character. We could imagine the a string function would return this &quot;first letter&quot; even if it is a digram/trigram, with something like {{#collatefirst:locale|string}}. For example {{#collatefirst|br|Christian}} would return &quot;ch&quot; because it is a single letter in Breton, and it is the first in the primary collation group that contains also contains &quot;cH&quot;, &quot;Ch&quot; and &quot;CH&quot; in Breton, sorted between &quot;c&quot; and the trigram &quot;c'h&quot;, the later is also distinct and comes before &quot;d&quot;). Such cases (named contractions in UCA) are frequent and needed in Spanish and Nordic languages.

== STEP TWO ==

* Then, if articles are categorized without any DEFAULTSORT: key and without sort key parameter, use the same function to automatically use this function to generate their collation key but ONLY when displayin the category, using the project's default locale, or with the locale specified within that target category (but don't store the collation key with the article, unless you are ready to have a server update task that will be able to recompute the collation keys of pages and subcategories that have been categorized in it, because the locale of a category could change over time, or could be set much later) :

* Category pages would contain their own option to specify their prefered collation, some thing like {{DEFAULTCOLLATE:languagecode}} in the text of that category page, to change it from the default's project locale/language (this additional and magic keyword would only be meaningful for category pages, and distinct from the string function above).

* But this would not prohibit pages to set their own sort key if they wish so when they categorize themselves in such category.


I am convinced that there's no need to use collation locales according to user's own preferences, the locales should be a property of both the project site and of the target category (which should be specific to a given reference language, so that it can effectively specify itself what is its prefered locale. For this reason, the collation key can be stored as it is today, when assigning different sortkeys for the same page but within distinct categories.

Having the string function {{#collate:language|string}} would still allow to sort some pages in specific groups (like &quot;*&quot; today in many wikis, for special elements that require higher priority in categories with large enough populations).</pre>
    </div><div id="c120" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c120">Comment 120</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-09-29 06:46:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note with my example sort key format, compatible with collation :

I gave &quot;cle !élc !Clé&quot; as a french collation key for &quot;Clé&quot; (remember, here the level separator is &quot; !&quot;, i.e. space+first non space, because MediaWiki drops multiple spaces : this sequence is not needed for any primary level key because the punctuation is normally dropped at this level and replaced by spaces, then sequences of spaces are packed to single one)

But nothing prohibits you to use this format instead: &quot;c le !élc !Clé&quot;

i.e. with an extra space separator between the firstChar() and the rest of the primary-level key.
This space is enough to generate the section titles in categories (so here it will effectively sort in section &quot;c&quot;...


For the Breton example, &quot;Christian&quot; will give this collation key : &quot;ch ristian !naitsirch !Christian&quot;

(note that Breton also uses accents and treat them like in French dictionnaries, in reversed order at the secondary level, i.e. from the last letter or digram or trigram, to the first one), so it will be displayed in section &quot;ch&quot;, and not &quot;c&quot;.
</pre>
    </div><div id="c121" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c121">Comment 121</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Stu Derby</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-10 01:42:13 UTC
        </span>
      </div>



<pre class="bz_comment_text" >In <a href="show_bug.cgi?id=164#c116">comment #116</a>:
<span class="quote">&gt; since wikipedia in some languages has thoroughly fixed the collation in category pages by using the custom sort key</span >

No, the custom sort key is still a hacky workaround that's less than thorough; not least because even with a custom sort key, the sorting is still case-sensitive. To achieve the proper case-insensitive sort that a normal reference work uses (in English at least), the en wikipedia is more-or-less using an ad-hoc casing rule - &quot;first-letter uppercase, all others lower&quot; - and there are lots of articles not 100% correctly &quot;fixed&quot; in this way.

Furthermore and FYI, on en, some folk have decided that case-sensitivity in the sort is a feature, not a bug.</pre>
    </div><div id="c122" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c122">Comment 122</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Laurent Jauquier</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-16 21:58:22 UTC
        </span>
      </div>



<pre class="bz_comment_text" >5 years old! This major (!) bug must absolutely be fixed. This makes no sense in our indexes! « À » is sorted after « Zèbre » !!</pre>
    </div><div id="c123" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c123">Comment 123</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-16 22:01:11 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c122">comment #122</a>)
<span class="quote">&gt; 5 years old! This major (!) bug must absolutely be fixed. This makes no sense
&gt; in our indexes! « À » is sorted after « Zèbre » !!
&gt; </span >

We know. Please don't spam this bug with comments like &quot;I WANT THIS TO BE FIXED!!!&quot;. Only comment when you have something technical and relevant to say.</pre>
    </div><div id="c124" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c124">Comment 124</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-17 08:25:28 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If you &quot;know&quot;, why do you change the severity level back to &quot;normal&quot;? This is a really fundamental bug - maybe developers living in their ASCII world don't realize it, but for people who write dictionaries and encyclopedias (which is what this software is most famously used for), particularly non-English ones, it really is a major impediment to quality. Can we at least have some information as to what is being done about this (we're told there's no shortage of ready solutions), and roughly when we can expect a fix to be implemented?</pre>
    </div><div id="c125" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c125">Comment 125</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Varga Benjámin</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-17 13:26:56 UTC
        </span>
      </div>



<pre class="bz_comment_text" >+1. It really seems to us, that the severity of this problem is not clear enough for those living in &quot;ASCII world&quot;. ;) Any solution will be greatly appreciated...</pre>
    </div><div id="c126" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c126">Comment 126</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Michael Zajac</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-17 23:47:42 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I agree with le Chat: how can any dictionary or encyclopedia be taken seriously if it can't even alphabetize its headwords or entries?  This is a fundamental requirement.</pre>
    </div><div id="c127" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c127">Comment 127</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Alex Z.</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-18 00:01:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" >As Roan said a few comments ago, please only comment when you have something *technical and relevant* to say. We already know that its a problem.
</pre>
    </div><div id="c128" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c128">Comment 128</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-18 11:55:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >It seems that the developers *don't* know that it's a problem; or at least, since it's taking over five years to solve, they don't appreciate how much of a problem it is. When I wrote with something technical and relevant I was told it wasn't required since we already know how to solve this problem - I don't know what else we can do to drive the point home that we *really really* should have a solution implemented. Can a dev at least answer my question about what is being done about this and when we can expect a fix to be made? (Changing severity back to major, in case that has any effect on focusing minds.)</pre>
    </div><div id="c129" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c129">Comment 129</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mormegil</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-18 13:55:55 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c128">comment #128</a>)
<span class="quote">&gt; I don't know
&gt; what else we can do to drive the point home that we *really really* should have
&gt; a solution implemented.</span >

What you can do to have a solution implemented? Write the code. This is an open-source project, after all…

<span class="quote">&gt; Can a dev at least answer my question about what is
&gt; being done about this and when we can expect a fix to be made?</span >

“A dev”? “What is being done”? This is an open-source project developed primarily by volunteers. AFAIK there is no official paid-by-Wikimedia-Foundation project to implement this functionality. You can hardly detect whether some volunteer somewhere spends his time working on this (and I know of no such person). We cannot expect a fix to be made until somebody goes and creates it…

Go implement the functionality, or go and bug the Foundation to throw some money on the problem and assign a paid developer to it. There is no point in debating the severity of it *here* (it’s not like there are bored developers lurking around here and not fixing the bug just because they do not consider it a problem).

OTOH, should the bug really be “ASSIGNED to Philip Tzou”? Is he actively working on solving this bug? I see he attached his patches here, but that is only a part of the solution.</pre>
    </div><div id="c130" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c130">Comment 130</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-18 17:20:05 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Well, there are people who know the architecture and the programming language and can presumably do this very quickly (at least the basic step) if they realize how much of a priority it is. The first step is just to apply a few extra functions to category sort keys with the intention of converting them into collation keys. Once that's in place, people can work on actually writing such functions for their particular languages. Later, when those functions are written, they can be used additionally to generate a proper alphabetically ordered table of pages for use in the contents listings. Or some similar workflow - but there needs to be a plan of action, and that can't be effected by just anyone, only by the devs who are in charge (no use pretending that everyone's equal - only certain devs actually have the power to make anything happen).</pre>
    </div><div id="c131" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c131">Comment 131</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 08:11:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt; Well, there are people who know the architecture and the programming language
&gt; and can presumably do this very quickly (at least the basic step)</span >

Why do you presume it can be done quickly? It doesn't seem so to me and I
regard this bug to be of huge importance.

<span class="quote">&gt; if they realize how much of a priority it is. The first step is just to
&gt; apply a few extra functions to category sort keys with the intention of
&gt; converting them into collation keys.</span >

Which functions would those be? What makes you think category sort keys can
be converted to collation keys?

For instance category sort keys are human-readable and human editable but
collation keys are typically binary and not human readable. Category sort
keys are included directly in the text of a category link such as
[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3Afoo">Category:foo</a>|bar]].

Do to their binary nature collation keys cannot appear here. So you would
need to decide whether to remove all category sort keys or make category sort
keys interact with collation keys that would be added elsewhere.

For collation keys to replace category sort keys you would need to establish
that cateogry sort keys have no legitimate uses other than forcing alphabetic
order in cases where the current order results in nonalphabetic sequences.
I can assure you that people do use category sort keys for other purposes and
some might be vociferously upset if these were removed without discussion.

For collation keys to interact with category sort keys you need to generate
and maintain in the database, collation keys for each page title and for each
category sort key since collation keys must be of the same nature to be able
to compare and hence sort them.

Now Unicode does specifiy a &quot;Unicode Collation Algorithm&quot; (UCA) which we could
and probably should use. It is language agnostic but provides for &quot;tailoring&quot;
for individual languages.

The UCA definitely generates binary keys. Not printable. Not human readable.

UCA keys can be very long. I use them in an offline tool for the English
Wiktionary and initially set their maximum length to 1024, 4 times the maximum
length of a page title. We already had about 10 pages for which 1024 was too
short so I had to set it to 2048! Many people might not like all page titles
and category sort keys to now require 9x their current amount of space in the
database.

UCA does allow for various types of sort key compression however. In which case
we would need to choose one to use since it will not be possible to mix and
match them.

PHP currently seems to have no implementation of UCA. We would need to create
it from scratch, or find a way to use one in C.

For multilingual wikis such as Commons and all of the Wiktionaries just havine
one collation language will not work since users of each language will expect
things to be in the correct order for their language.

For the Wiktionaries this means each category needs a way to declare which
language collation to use and each page needs to declare which subset of possible
language collation keys to generate for that page.

For Commons I'm not sure what the requirements would be but the may differ from
those of the Wiktionaries.

These new fields will need support in the database schema. The ones requiring
multiple language collations will reqire more drastic database changes quite
different from what we now have.

<span class="quote">&gt; Once that's in place, people can work on actually writing such functions for
&gt; their particular languages. Later, when those functions are written, they can
&gt; be used additionally to generate a proper alphabetically ordered table of
&gt; pages for use in the contents listings. Or some similar workflow</span >

UCA tailoring would make the particular language collations very easy as long as
we have a decent implementation of UCA that easily works with tailoring.

<span class="quote">&gt; - but there needs to be a plan of action, and that can't be effected by just
&gt; anyone, only by the devs who are in charge (no use pretending that everyone's
&gt; equal - only certain devs actually have the power to make anything happen).</span >

Not true. Anyone with commit access can add such code. Myself for instance.
My understaning is that there are not technically any dev in charge at the
moment since Brion stepped down though there certainly are a few such as Tim
who are acknowledged to have a greater understanding of the entire codebase
and hence greater trust, and you definitely want those people to check such
changes and would expect them to revert any premature commits.
</pre>
    </div><div id="c132" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c132">Comment 132</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philip Tzou</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 08:27:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'm busy with my study and I can't help this until I have passed my exam next year January. I'm sorry to make your guys unhappy, though Chinese Wikipedia also needs such functions. :)</pre>
    </div><div id="c133" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c133">Comment 133</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 12:53:22 UTC
        </span>
      </div>



<pre class="bz_comment_text" >We seem to be overcomplicating things now. Of course category sort keys and binary collation keys are different beasts. We just need a couple of stub functions (we - or rather individual projects - can worry about what they should do later), F1 and F2, such that F1(T) means the collation key derived from page title T, and F2(K) means the collation key derived from human-readable category sort key K (the two functions will be similar, but potentially not identical). Then apply them at the appropriate places in the code generating the category listings. There will also need to be a function that retrieves the first letter back from a binary key, as has been noted. All these functions will be language- and project-dependent - no-one is in a position to write all of them, but once the basic (and trivial) framework is in place, people who know about the various languages will be able to work on writing these functions. If a project thinks it needs the option of multiple sort algorithms, then that's pretty simple to implement as well, though starting with just one algorithm per project seems perfectly satisfactory - all the main public-facing projects are language-specific anyway, so even if English Wiktionary contains Czech words, we would still expect them to be sorted in the English order.</pre>
    </div><div id="c134" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c134">Comment 134</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 13:51:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Collation keys can coexist with custom sort keys.
Custom sort keys are useful and will continue to be useful, to tweak the default collation (which for now is simply a binary ordering of codepoints).

Tdoday, basically, the categories are sorted by [sort key, full page name]. (possibly truncated to a reasonable size using unique identifier).

What we want is to be able to sort by: [collationkey([sort key, full page name]), sort key, full pagename) (also with possible truncation of the whole). 

This will preserve the existing tweaks made in pages when they reference categories, and will help sort all the rest.

Ideally, the collation keys should be generated &quot;on the wild&quot; by the SQL engine itself (because it would allow alternate sort orders, according to user locale preferences or according to web query parameters set by GUI buttons, especially for Chinese where several sort orders are common: sort by Pinyin, sort by radical/strokes, sort by traditional dictionary orders), as part of its supported &quot;ORDER BY&quot; clause for getting the list of article names to display in categories.

But if the SQL engine does not have such support, this must be implemented in the PHP code and collation keys can be stored in a new datacolumn (the extra data column can be added or filled conditionnally : if the SQL engine supports the needed collations, this column can remain NULL to save storage space).

If the SQL engine does not have support for dynamic collations, then the alternate (user locale-based) sort orders will not easy to implement because of the cost that it would require in the SQL client-side (in PHP) for heavily populated categories, where the support for true locale-based collation orders is the most wanted, unless the database can store multiple collation keys (for distinct specific locales): supporting the storage of multiple collation keys for different locales can severaly impact the server performance as it would require an extra join to a separate 1:N table to store the collation keys indexed by (pageid, locale); instead of storing these keys in the same SQL table used for storing the category index.

Additionally, the stored collation keys will sometimes need to be updated (when the CLDR data for locale-tailored collations will be updated or when there will be updated in the Unicode version with new characters): updating a large volume of stored collation keys will require a lot of work, and this can impact the availability of the wiki project, unless the data model includes a versioning system that allows at least two versions for the same locale to coexist for some time, and then allows switching from one version to the next before cleaning up the old collation keys after the collation keys have been updated to the new tailoring.
</pre>
    </div><div id="c135" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c135">Comment 135</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 14:03:26 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Finally, the proposed patch for Chinese is not sufficient. It just supports a single collation, and is not suitable. It will require lots of works to support other locales.

I really suggest that such patch uses either the SQL-supported collations, when they exist for wellknown locales, or that the collation keys are computed using a strong and well supported design, most probably ICU for C (already available as a extension module for PHP and Perl) also available as ICU for Java (and that can be integrated in some SQL engine backends), that natively includes the support for CLDR locales (and their widely discussed tuned standard tailorings), in addition to easy integration of locales using MediaWiki supported tailorings (using the LDML syntax) for the locales currently not supported in CLDR but needed for the many languages that MediaWiki sites support.</pre>
    </div><div id="c136" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c136">Comment 136</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 14:13:17 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'm assuming the SQL engine doesn't support this (if it did, then it would have been turned on years ago, right?) But I don't understand the emphasis on multiple locales - the main need is just for ''one'' sort algorithm per database (any more would be a luxury). The human-&gt;binary algorithm just needs to be applied once when a page is added to a category; I don't see any major performance issues resulting. (Of course there would be inconsistencies for a time after the algorithms have been rewritten, but we wouldn't expect any tweaks to those algorithms to have a major impact on the sort order.)</pre>
    </div><div id="c137" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c137">Comment 137</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 14:17:38 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c134">comment #134</a>)
<span class="quote">&gt; Tdoday, basically, the categories are sorted by [sort key, full page name].
&gt; (possibly truncated to a reasonable size using unique identifier).
&gt; </span >
This is not true. We're sorting by (sort key, pageID) where the sortkey is whatever the page sets as sortkey (or the page name if not set), and pageID is a unique number identifying the page (roughly proportional to creation time).

<span class="quote">&gt; Ideally, the collation keys should be generated &quot;on the wild&quot; by the SQL engine
&gt; itself (because it would allow alternate sort orders, according to user locale
&gt; preferences or according to web query parameters set by GUI buttons, especially
&gt; for Chinese where several sort orders are common: sort by Pinyin, sort by
&gt; radical/strokes, sort by traditional dictionary orders), as part of its
&gt; supported &quot;ORDER BY&quot; clause for getting the list of article names to display in
&gt; categories.
&gt; </span >
SQL engines probably support this, but using it would result in an unacceptably inefficient query. Only queries sorting by the actual values of fields are efficient, and only if there is an index on those fields.

<span class="quote">&gt; But if the SQL engine does not have such support, this must be implemented in
&gt; the PHP code and collation keys can be stored in a new datacolumn (the extra
&gt; data column can be added or filled conditionnally : if the SQL engine supports
&gt; the needed collations, this column can remain NULL to save storage space).
&gt; </span >
If you sort this stuff in PHP, you need to grab the entire list before you can reliably sort it. Doing that for [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3ALiving%20people">Category:Living people</a>]] has no chance of staying within the memory limit.

<span class="quote">&gt; If the SQL engine does not have support for dynamic collations, then the
&gt; alternate (user locale-based) sort orders will not easy to implement because of
&gt; the cost that it would require in the SQL client-side (in PHP) for heavily
&gt; populated categories, where the support for true locale-based collation orders
&gt; is the most wanted, unless the database can store multiple collation keys (for
&gt; distinct specific locales): supporting the storage of multiple collation keys
&gt; for different locales can severaly impact the server performance as it would
&gt; require an extra join to a separate 1:N table to store the collation keys
&gt; indexed by (pageid, locale); instead of storing these keys in the same SQL
&gt; table used for storing the category index.
&gt; </span >
For supporting multiple collations, a separate table sounds a lot more sane in terms of read performance, as it would suffer less from the problems mentioned above.

<span class="quote">&gt; Additionally, the stored collation keys will sometimes need to be updated (when
&gt; the CLDR data for locale-tailored collations will be updated or when there will
&gt; be updated in the Unicode version with new characters): updating a large volume
&gt; of stored collation keys will require a lot of work, and this can impact the
&gt; availability of the wiki project, unless the data model includes a versioning
&gt; system that allows at least two versions for the same locale to coexist for
&gt; some time, and then allows switching from one version to the next before
&gt; cleaning up the old collation keys after the collation keys have been updated
&gt; to the new tailoring.
&gt; </span >
Expensive writes are better than expensive reads.</pre>
    </div><div id="c138" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c138">Comment 138</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 15:27:02 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt;If you sort this stuff in PHP, you need to grab the entire list before you can
&gt;reliably sort it. Doing that for [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3ALiving%20people">Category:Living people</a>]] has no chance of
&gt;staying within the memory limit.</span >

Not if you compute the collation key when you add a page to a category, and index it based on that key. (Just as you currently index it based on the human-readable sort key.)
</pre>
    </div><div id="c139" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c139">Comment 139</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 15:51:05 UTC
        </span>
      </div>



<pre class="bz_comment_text" >#88,#100,#101 &quot;Does UCA explicitly specify the binary representation of the generated
key?&quot;

yes and no:
- Yes there's an interface to retrieve the computed sort key.
- But no: it is not stable across versions of Unicode (which can add characters in the DUCET), of ICU (that can change the representation), and of CLDR (that can modify also the locale-dependant tailorings).

In other words : precomputed (stored) collations will need to be versioned too, any upgrade will require recomputing the collation keys (but a real problem on large wikis, if this is implemented in the SQL native engine (because the database index will have to be FULLY rescanned and updated, which may take a considerable down time on large wikis).

This will be much less problematic if the colaltion keys are not part of the SQL engine itself, but stored in a separate table that can store multiple keys for distinct collations, because it can also be used for storing successive versions. In that case, recomputing the collation keys can be deferred, and once a category is finished, the collation version can be updated in the category, and then the collation keys for the previous version can be deleted, and then the next category can be handled. This will imply NO downtime on the server, as new collations can be added on the fly (and separately for each category).

Consequence: add to the MediaWiki data model a table of supported locales-collation (those that can be specified in the site-wide default) with their supported version. Attach a unique id for the versioned collation, and create a separate category collation table containing the collation keys.

Conceptually (some details omitted) :

CREATE TABLE collations(
  coll_id INTEGER NOT NULL,              -- primary key for this table
  coll_name VARCHAR(32) NOT NULL,        -- e.g. &quot;root&quot;, &quot;fr&quot;, &quot;en-US&quot;, &quot;en-GB&quot;, &quot;zh-Latn&quot;, &quot;zh-Bopo&quot;, &quot;zh-Hans.radical-strokes&quot;
  coll_isprefered SMALLINT NOT NULL,     -- identifier of the version
  coll_version VARCHAR(32) NOT NULL,     -- unique description of the version
  PRIMARY KEY (coll_id),
  UNIQUE KEY(coll_name, coll_version),   -- strong constraint
  INDEX ON (coll_name, coll_ispreferred) -- optional, for fast retrieval of the prefered version of a given collation
);

CREATE TABLE categorysort (
  cl_id INTEGER NOT NULL,   -- in fact, the primary key of the categorylinks table
  coll_id INTEGER NOT NULL, -- primary key of the collations table
  cs_key VARCHAR(255),      -- in fact a binary value, computed from ICU's Collator:getKey(UString).
  PRIMARY KEY(cl_id, coll_id)
);

Then no need to change the categorylinks table, which will continue to store the full pagename, and the custom sortkey.

----

To support the firstChar() conceptual API, each entry in the collations table above would also need another table containing the possible lowest strings (in collation order) that use the same weight value at the primary level:

CREATE TABLE collations_headings(
  coll_id INTEGER NOT NULL, -- primary key of the collations table
  ch_weight INTEGER NOT NULL, -- primary collation weight value
  ch_cluster VARCHAR(32) NOT NULL -- single default grapheme cluster from the first string starting with this primary weight. 
  PRIMARY KEY (coll_id, cf_cluster)
)

One problem is that ICU does not currently contains such a list of default grapheme clusters suitable for all primary weight values in each collation. Is there a way to generate it anyway? Note that some primary weights can sometimes only exist with multiple characters

E.g. &quot;ch&quot; is a default grapheme cluster in the Breton collation, LC_COLLATE=br. It makes no sense in Breton to mix &quot;c&quot; and &quot;ch&quot; together under the same heading, given that they sort separately. The same thing occurs in many languages (e.g. Spanish, Swedish...).

However it probably does not occur (?) in the DUCET (I did not verify this assertion), so may be we can just avoid storing all possible Unicode characters to convert them to their default primary heading, and instead we just have to store the graphemes specified in the examplar set for the language (or other graphemes that are explicitly present in the locale specific tailoring rules.

The other graphemes usable as first char can then be taken automatically generated from the first Unicode character present in the Mediawiki custom cl_sortkey (whose default is the full pagename, including the namespace name localized to the default locale of the wiki), according to the DUCET which is shared as the base of all locales.</pre>
    </div><div id="c140" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c140">Comment 140</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 15:59:48 UTC
        </span>
      </div>



<pre class="bz_comment_text" >#138: I fully agree. Using stored collation keys will remove the dependency with the database support, and will also avoid the problem of downtime when upgrading the collations and recomputing the categorylinks SQL index to migrate the collation keys...

I still defned the concept of multiple collations in parallel, if only just for supporting the migration of collation rules.

In addition it will offer users preferences for their preferred collation order, and will also allow to view the same category using different orders, without additional processing (as long as the category page itself, or the site-wide default collations, specify the collations as supported by default)</pre>
    </div><div id="c141" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c141">Comment 141</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 16:09:07 UTC
        </span>
      </div>



<pre class="bz_comment_text" >#137 From Roan Kattouw 2009-11-19 14:17:38 UTC
<span class="quote">&gt;(In reply to <a href="show_bug.cgi?id=164#c134">comment #134</a>)
&gt;&gt; Tdoday, basically, the categories are sorted by [sort key, full page name].
&gt;&gt; (possibly truncated to a reasonable size using unique identifier).
&gt;&gt; 
&gt;This is not true. We're sorting by (sort key, pageID) where the sortkey is
&gt;whatever the page sets as sortkey (or the page name if not set), and pageID is
&gt;a unique number identifying the page (roughly proportional to creation time).</span >

I was speaking conceptually. The &quot;pageID&quot; is absolutely not conceptual and makes absolutely no sense lingusitically for most users, for sorting pages having the same sort key specified. We really want these pages to be sorted according to the specified sort key (when it is present), then by the full page name; and both using the same locale-dependant collation order.

The pageID was just added to make sure that the sort key was unique (actually this is not a requirement), and for allowing navigation from page to page without missing entries or duplicating them across pages, but it is definitely not part of a good sort key (this is the only reason why we want a unique id there, but in fact it is redundant and is an alternate binary representation of the full pagename which is also unique, but which is completely unsuitable for collation).</pre>
    </div><div id="c142" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c142">Comment 142</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 16:40:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c141">comment #141</a>)
<span class="quote">&gt; The pageID was just added to make sure that the sort key was unique (actually
&gt; this is not a requirement),</span >
It is a requirement software-wise. If two categorylinks entries are indistinguishable, category paging will break.

<span class="quote">&gt; and for allowing navigation from page to page
&gt; without missing entries or duplicating them across pages,</span >
Exactly.

<span class="quote">&gt; but it is definitely
&gt; not part of a good sort key (this is the only reason why we want a unique id
&gt; there, but in fact it is redundant and is an alternate binary representation of
&gt; the full pagename which is also unique, but which is completely unsuitable for
&gt; collation).
&gt; </span >
Yeah the full page name could also be used as a tiebreaker (from a technical standpoint we probably want a (namespace, title) pair instead, where namespace is a numeric value).</pre>
    </div><div id="c143" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c143">Comment 143</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 17:58:47 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(in reply to <a href="show_bug.cgi?id=164#c142">comment #142</a> from Roan)

<span class="quote">&gt;The pageID was just added to make sure that the sort key was unique (actually
&gt;&gt; this is not a requirement),
&gt; It is a requirement software-wise.</span >

Absolutely not, it is not required FOR SORTING (this was explicitly stated in my previous statements, dont cut it where you think it arranges you). It does not have to be &quot;software-wise&quot;, because exactly it is completely undesirable for sorting.

You are confusion uniqueness requirements (for navigation and indexing for fast SQL retrieval) with sort order requirements. The need for the separate id is completely orthogonal, because the ID is just a small alias strictly equivalent to the full page name that it represents (i.e. to the unique identifier created by the namespace and the page name, which are what we really want to show and sort, but not what we need to avoid duplicated or missed entries in the &quot;next 200&quot;/&quot;previous 200&quot; links). Such page id should always remain invisible in the GUI interface (only visible in the URL as a query parameter for the next/previous 200 links), and should be COMPLETELY ignored by the SQL &quot;ORDER BY&quot; clause, even if it MUST still be part of the SELECT'ed columns in the SQL query.

----

Couldn't the namespace be part of the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category-sort-option%3A">category-sort-option:</a>]] or similar ? Currently they are sorted by name (and the initial of the namespace name is also used to generate the headings : it is convenient for some categories, but not all, and in fact, the namespace could be used to generate other subheading levels, or given lower prirority when compared to the unprefixed pagename.

I see no valid option for sorting by numeric namespace id (except for sorting by namespaces, independantly of their name), and at least it should never be made visible in the &quot;first char&quot; used in section heandings...

So may be another [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category-ns-option%3A">category-ns-option:</a>]] could be set in category pages (but this will probably be part of another proposal for enhancement).
</pre>
    </div><div id="c144" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c144">Comment 144</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 18:12:31 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that in SQL, the ORDER BY clause needs NOT unique sort keys.
Not even for sort stability, because the SQL engine will ensure the sort stability itself from the default store order in the index (when there's a qualifying index for this sort order), or from the implicit positional &quot;rowID's&quot; automatically for each SELECT'ed row added to the temporarily created table/index during the query execution.

Some SQL engines (like Oracle, Sybase, Informix, but probably not all index formats supported in various versions of MySQL) also store the rowID's of the component tables from which columns are extracted in the SELECT clause, in order to allow the columns under the read cursor to be updatable, but won't do that for columns computed from expressions, which are not updatable. This just requires opening the cursor &quot;FOR UPDATE&quot; (and sometimes, you can also limit the list of table columns that need to be updated within the cursor loop, which remains open during the transaction, in order to minimize the extra storage for dependant rowID's).</pre>
    </div><div id="c145" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c145">Comment 145</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-19 22:13:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c144">comment #144</a>)
<span class="quote">&gt; Some SQL engines (like Oracle, Sybase, Informix, but probably not all index
&gt; formats supported in various versions of MySQL) also store the rowID's of the
&gt; component tables from which columns are extracted in the SELECT clause, in
&gt; order to allow the columns under the read cursor to be updatable, but won't do
&gt; that for columns computed from expressions, which are not updatable. This just
&gt; requires opening the cursor &quot;FOR UPDATE&quot; (and sometimes, you can also limit the
&gt; list of table columns that need to be updated within the cursor loop, which
&gt; remains open during the transaction, in order to minimize the extra storage for
&gt; dependant rowID's).
&gt; </span >

Let's not make assumptions about individual DB engines here, but use SQL queries that unambiguously state what we want without relying on such behavior.

About the whole page ID thing: as long there's a sorting tiebreaker of some kind making every entry unique (not necessarily visibly unique in the UI, just unique to the software), paging will be fine. Whether that tiebreaker is the page ID or the page title or the water level in the San Francisco Bay at the time of the page creation measured in 128ths of inches doesn't matter all that much from the implementation side, although of course only the second is remotely understandable for users.</pre>
    </div><div id="c146" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c146">Comment 146</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 00:11:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I did not make assumptions about SQL engines, because this message exactly says the opposite: there are varieties there, and Mediawiki could/should also work with other SQL backends then just MySQL, even if it is open-sourced, but mainly supported now by Sun which has its own strategies on it.

But I wanted to really note that the page id had no use for sorting results, given that we really want to sort by full page name, as a single entity or split in two parts if we consider the namespace...

And may be into more parts, if we consider the subpage names that are also part of the full page name by specially tailoring the &quot;/&quot; character in the collation order so that &quot;a/c&quot; will still sort with sort with &quot;a&quot;, and not after &quot;ä&quot; or &quot;a!&quot;, by giving a less than minimum primary weight to the &quot;/&quot; character used as subpages separator (a value even before characters with default-ignorable primary weight values).

Another way to perceive multicolumn hierarchical sort keys is to think about them as if they were separated in a single string by an implicit (non-coded) character with a non null but less than minimal primary weight value lower than default ignorable characters. In UCA impelmentations there a reserved weight for this function (fully ignorable characters get the null primary weight which does not participate at all to the computed collation key, this invisible character takes the next weight, and then the default-ignorable characters come just after, followed by combining characters, then whitespaces, and then generally in the order: punctuation and symbols, numerals, letters and ideographs).

This implicit separator may be the same as the one for separating series of weight at each level within the same source string (but many UCA implementations, including ICU, do not need to encode this separator in the computed multilevel collation key, as they allocate the collation weights in non overlapping numeric ranges where the highest one is used for the primary weights ; but they still maintain a reserved value for easily computing multicolumn sort keys by simple concatenation with the encoded binary primary weight for this the column separator).

Note also that in UCA, some groups of distinct strings, whose collation key are computed at the maximum level (generally level 4 with the DUCET, but possibly longer in collations tailored for some complex languages), can still have the same collation key: this will be true if the stricts contain different characters, but they are still canonically equivalent (i.e. they have the same NFC form). One string in each subgroup will be in NFC form, the others are in alternate non canonical forms and may even be longer):

It is not a problem for language-sensitive collation, but effectively this sometimes requires adding a final binary comparison between the Unicode-encoded strings, to make sure that the sort order will be stable across database updates (such comparison needs not be stored in the collation key itself, given that we will still retreive the full page name from the database, for displaying them, and not just the collation key which is just used in the ORDER BY clause.</pre>
    </div><div id="c147" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c147">Comment 147</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 01:50:55 UTC
        </span>
      </div>



<pre class="bz_comment_text" >MySQL does support CLDR/UCA collation and I believe it to be fast. The reason we don't use it is that MySQL does not support the full range of Unicode whereas MediaWiki does. MySQL is limited to the BMP (Basic Multilingual Plane). I believe for this reason MediaWiki does not even use any of MySQL's support for UTF-8 but instead stores all text as binary and handles UTF-8 issues itself.

The feature request for non-BMP support in MySQL seems to be this one marked low priority with only 2 people watching it: <a href="http://forge.mysql.com/worklog/task.php?id=1213">http://forge.mysql.com/worklog/task.php?id=1213</a>
</pre>
    </div><div id="c148" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c148">Comment 148</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 04:25:06 UTC
        </span>
      </div>



<pre class="bz_comment_text" >May be it's low in their priority, but with the development of Unicode and the now ongoing efforts to add now many more characters in plane 1 (notably lots of symbols, including common things like circled letters and numbers) and 2 (ideographs) for modern use, this position will become unmaintainable, and the need for extending the MySQL UTF-8 support will increase.
After all, MySQL is now controled by Sun, which is an active member of Unicode Technical Commity, and even Sun will want a better interfaction with its Java platform that has excellent Unicode implementation and is used as a reference platform (even before the newest algorithms are ported to C/C++). ICU is also supported by IBM that has a strategic need in C/C++, Java, and intergration in web services (both on the server- and client-side of applications).

Here also IBM wants itegration with its dB2 SQL platform but has siognificant offers over MySQL. Both companies (also Apple, Oracle, and many others) are highly engaged in the Unicode development process, internationalisation, and want support for their platforms (including in China, where currently MySQL will not be an option, as long as full support of Unicode will not be there).
in fact, extending the support to the missing plnes is now a small effort in comparison to what has already been made by them. And another refernce platform (Perl) can also help generate the missing code or data tables that are needed (the PHP platform makes no efforts itself, as its Unicode support completely depends on ICU now, which is now a reference library that is becoming nearly universal on all platforms, with the except of Windows where Microsoft has rewritten everything in its CLR for .Net). May be MySQL will sooner or later replace its own implementation simply by integrating ICU, to save the collaborative efforts...

The only seriously missing development for collation for now is on the client side: we still lack a good support of collation in Javascript (which just as a string.localeCompare(string) method with an unspecified collation table, and incompatible implementations across browsers with lots of bugs.): the few demonstrations that I have seen need to use server-side components to actually collate or process the Unicode data through AJAX! I think that this will come when JSP server-side applications will start to want Collators without depending on native libraries (that cannot be deployed easily from servers to servers, or over computing grids). Collator factories should become as universal in I18N framewaorks, as it is now for translation resource bundles, date/time formats, case mappings, encoding convertors, and regular expressions.

So are there voluntaries to implement it in MediaWiki using its native PHP platform (through the intl10n library), independantly of MySQL (which is just a backend, from which MediaWiki should not heavily depend exclusively).</pre>
    </div><div id="c149" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c149">Comment 149</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 11:05:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I've added some feedback on the MySQL bug. I urge anyone here who cares about this bug to also pay attention to that bug. Perhaps by working on their code, perhaps voting for the bug, perhaps providing further helpful feedback. Perhaps they will raise its importance if they see it is important for MediaWiki and Wikipedia - a top 5 website. I believe MediaWiki and MySQL have worked together in the past.

<a href="http://forge.mysql.com/worklog/task.php?id=1213">http://forge.mysql.com/worklog/task.php?id=1213</a>
</pre>
    </div><div id="c150" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c150">Comment 150</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Peter Gervai (grin)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 15:09:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Well I didn't want to chime in (you seem to be able to shout at each others without my assistance :-)) but please do not forget that the solution for MEDIAWIKI (as opposed to Wikipedia) ought not base on Mysql specific features. 

If there are two approaches, and one of them is database backend agnostic then that one should be preferred.

Of course I didn't want to mention that I believe code speed (resource hunger) is a real factor here, since this is accessed frequently.

By no means I want to speak against helping Mysql, since it's a nice open source project. I just use postgresql, that's all. :-)</pre>
    </div><div id="c151" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c151">Comment 151</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-20 15:43:56 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Anyway, the backend compatibility layer that maps the SQL into the SQL dialect spoken by the SQL engine can still adapt itself : if there's a true support for collation supported by the SQL backend, it can be used instead of the client-side (in PHP) implementation in the MediaWiki code itself, if it provides additional performance benefits and stronger security. If there's no real difference, then we can simply abandon the SQL-based collation (even if its supported) and use the PHP implementation everywhere

This will simplify the design of the SQL-backend adaptation layer within the MediaWiki code.

This will allow easier integration of other backends, such as Postgres (suggested in <a href="show_bug.cgi?id=164#c150">Comment #150</a>), or Oracle, Sybase, Informix, MSSQL, or other backends available on Windows servers through ODBC, or others accessible through JDBC via a PHP-to-Java adaptation layer... if the PHP code used in MediaWiki can also run from within a Java-based JSP application server or .Net-based ASP application server, or from within other newer VMs that are already being developed to support both the Java and .Net environments simultaneously. There are very exentive research to make all these VMs compatible with each other (and to ease the migration with mutual compatibility, and with transparent deployment facilities in heterogeneous environments like computing grids and cloud computing).

Note that in some future, even the WMF projects could benefit a lot of such facilities, when its servers will be virtualized to scale better with reduced costs, because we all know that the WMF projects need more and more money each year to support its ever growing databases and audience, and the increased need for supporting better internationalization. It is highly strategic (and should also be discussed in the WMF Strategy wiki) to reduce the technical  dependencies (also because there's now a demonstrated need for open-projects to work together, such as within the Open Alliance which has lots of contents to share with the WMF, thanks to their compatible licencing schemes).</pre>
    </div><div id="c152" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c152">Comment 152</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Anthony</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-25 05:42:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Peter, for PostgreSQL you can ignore all the hacks and workarounds and just use the built in collation.

psql (8.4.1)
Type &quot;help&quot; for help.

a=# create table category (title varchar(255) not null primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index &quot;category_pkey&quot; for table &quot;category&quot;
CREATE TABLE
a=# insert into category values ('Apple');
INSERT 0 1
a=# insert into category values ('Banana');
INSERT 0 1
a=# insert into category values ('aaa');
INSERT 0 1
a=# insert into category values ('banana');
INSERT 0 1
a=# insert into category values ('aáa');
INSERT 0 1
a=# insert into category values ('apple');
INSERT 0 1
a=# insert into category values ('Apple');
ERROR:  duplicate key value violates unique constraint &quot;category_pkey&quot;
a=#  insert into category values ('APPLE');
INSERT 0 1
a=# insert into category values ('aab');
INSERT 0 1
a=# select * from category order by title;
 title
--------
 aaa
 aáa
 aab
 apple
 Apple
 APPLE
 banana
 Banana
(8 rows)

The easiest solution would probably be to drop support for MySQL.  Not that that's ever going to happen.</pre>
    </div><div id="c153" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c153">Comment 153</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-25 07:57:50 UTC
        </span>
      </div>



<pre class="bz_comment_text" >MySQL can do the collation that Anthony mentions for PostgreSQL above in #152 and much more besides.

PostgreSQL has all the problems and more of MySQL when it comes to MediaWiki's collation needs. It depends on the underlying OS, some of which don't do UTF-8 collation at all and as yet does not make us of ICU. See the page here: <a href="http://wiki.postgresql.org/wiki/Todo:ICU">http://wiki.postgresql.org/wiki/Todo:ICU</a>

I can't find any information on whether PostgreSQL supports Unicode beyong the Basic Multilingual Plane.
</pre>
    </div><div id="c154" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c154">Comment 154</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-25 23:06:01 UTC
        </span>
      </div>



<pre class="bz_comment_text" >That's another good resson why collation should be supported directly within the MediaWiki software, which already depends completely of PHP, so that it should really use the best integration as possible using the dedicated ICU integration module for PHP.
This also means that it will be much better to simply store the computed collation keys directly within the database schema, unless the database adapter for PHP already supports ICU (and there's a commitment from the database vendor to integrate ICU as part of its design).
The Todo:ICU in PostgreSQL will be fine when it will be effectively implemented, and this integration becomes fully supported.
But anyway, the first thing to do is to press the PHP developers to have their own commitment to offer full support and integration of ICU within PHP, and if this is still nto the case, making sure that the ICU integration module for PHP comes from a viable project (otherwise there will be the need, in MediaWiki, to develop an adaptation layer for collation, that will support transparent change for another PHP integration module, or a later integrtion within PHP core itself).

The second thing to look for (and that is still missing) is a support for a ICU-like project (or port) for Javascript (for integration on the client-side, in the browser) with here also an Javascript-written adapter layer, that allows replacement of the Javascript-written collator by some future API supported natively by browsers (because it will perform much better).

The best integration tools (for client-side collation) that I have seen, using Javascript, fully depends on AJAX (i.e. with collaboration with serverside-scripts that can provide precomputed collation data, or that can compute the collation keys from the client-provided texts): some interesting demos use JSON requests or XML requests though AJAX, but this adds some delays and increases the number of HTTP requests needed to sort lots of client-side data (for example when sorting the rendered HTML table columns, which currently just uses the Javascript &quot;localeCompare&quot; function which seems to use only the DUCET or some locale-neutral collation, without taking into account the actual locale).

It would be much better if all major browser engines (for IE, Mozilla for Firefox, Wekbit for Safari/Chrome/KHTML) decided to extend the very poor support of Unicode and locales within Javascript/ECMAScript strings, using ICU as a base foundation or at least for the services API that it can implement (even if those browsers use different integration strategies): they should still support the same collation rules, with the same syntax in a similar language, such as the languages already documented in the Unicode standard, including the possibility to use the collation tailoring data already coming the CLDR project, and the possibility for these implementations to still support user-specified tailorings (so without hardcoding them in a way that would completely depend on the implemented Unicode version and the limited list of locales already supported by CLDR).

There are two standard languages defined for collation tailorings : one is XML-based but is extremely verbose (it is probably easier to use from a DOM-based object view, and most probably more efficient at run-time), another equivalent one is much more compact and more readable and much easier to specify by users or in scripts. Both syntaxes are automatically and easily convertible between each other, with equivalent compilation times and complexities, but the comapct form is easier to transmit in small scripts over HTTP (including through AJAX), and the compact form is much faster to parse as it won't depend on a ressource-hungry XML parser (due to its required and complex conformance rules). For Javascript clients, a JSON-based syntax for collation tailorings may also be even more efficient without requiring additional complex code written in Javascript itself.
</pre>
    </div><div id="c155" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c155">Comment 155</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-27 02:07:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Here is another related MySQL bug to watch: <a href="http://bugs.mysql.com/bug.php?id=25666">http://bugs.mysql.com/bug.php?id=25666</a>
</pre>
    </div><div id="c156" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c156">Comment 156</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2009-11-27 21:50:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Apparently non-BMP UTF-8 was in MySQL 6.0 which was around as alpha for a while and whose features are all due to be added into upcoming 5.X versions: <a href="http://lists.mysql.com/packagers/418">http://lists.mysql.com/packagers/418</a>
</pre>
    </div><div id="c157" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c157">Comment 157</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Chris</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-01-19 16:35:07 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'm not sure if i'm posting in the right category, but I figured I should post it here before making a new one post.
There's a problem for sorting with Korean page names.
If the page is 가, it will sort under ㄱ if you don't specify where to sort it (which is what it should do).

However, if I manually sort it to like this: [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3Aname">Category:name</a>|ㄱ]] it won't sort under the same ㄱ as before. Instead it will make another ㄱ to sort under.
So making if a user manually sorts a page under ㄱ, and another has makes a page that starts with the letter ㄱ and mediawiki automatically sort it -- even though they should be sorted under the same letter, they are not. My mediawiki is the latest version by the way (1.15.1)

Incase your confused:

ㄱ
-가 (manually sorted page)

ㄴ
-(page)

.
.
.

ㅈ
-(page)

&lt;&lt;end of korean alphabet, there should be no more Korean letters, but pages that weren't sorted manually will appear after&gt;&gt;

ㄱ (appears at the end, identical letter as before and should not be recreated by mediawiki)
- 기 (a page that was sorted by mediawiki, this should be sorted in the same section as page &quot;가&quot;)
</pre>
    </div><div id="c158" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c158">Comment 158</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Le Chat</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-02-27 16:37:31 UTC
        </span>
      </div>



<pre class="bz_comment_text" >As I understand it, this bug was wrongly assigned to someone who is not working on it (at least, not in its full generality), so I'm boldly de-assigning it, in the hope that someone will finally take it up.</pre>
    </div><div id="c159" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c159">Comment 159</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">T. Gries</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-07 11:15:15 UTC
        </span>
      </div>



<pre class="bz_comment_text" >When setting up a new(!) wiki, and when using MySQL 4.1/5.0 UTF-8 (not: binary) a correct page title sort order can be achieved when applying this patch

in maintenance/tables.sql change 
  page_title varchar(255) binary NOT NULL,
to
  page_title varchar(255) NOT NULL,

before you run the installer.

The column page_title will then become of encoding type

  character set utf8 collate utf8_general_ci

and the sorting order of page titles is correct for (at least European languages). You then get page titles in Special:Pages listed in the order &quot;Anton&quot;, &quot;Äpfel&quot;, &quot;École supérieure&quot;, &quot;Zulu&quot; - and not any longer &quot;Anton&quot;, &quot;Zulu&quot;, &quot;Äpfel&quot;, &quot;École supérieure&quot; as is currently the case on all WMF wikis.

This tip is only valid for fresh installations: you cannot change this important column when updating from an existing database even not when mysqldumping and importing; attention: the tip has not yet checked for unwanted side effects.

For collations see 
[1] <a href="http://www.collation-charts.org/mysql60/">http://www.collation-charts.org/mysql60/</a> and 
[2] <a href="http://www.collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html">http://www.collation-charts.org/mysql60/mysql604.utf8_general_ci.european.html</a></pre>
    </div><div id="c160" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c160">Comment 160</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Stu Derby</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 01:32:28 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Re: <a href="show_bug.cgi?id=164#c159">comment 159</a> 

While the suggested patch clearly dramatically improves the page title sorting, it doesn't make it 100% correct for all &quot;European languages&quot; though it may make it so for some, and I think it would be an improvement for all but the Nordic languages.

The different European languages have different and conflicting collation sequences; no single order will work for all of them.

For example:

German speakers expect &quot;Ö&quot; and &quot;O&quot; to collate as equivalents; Danes, Norwegians, and Swedes expect &quot;Ö&quot; to be treated as a separate letter that sorts after &quot;Z&quot;.

French has an unusual collation rule; the last accent on a word is more significant than the first, leading to this collation:
cote &lt; côte &lt; coté &lt; côté. This is unique to French, so far as I know.

Hungarian sorts the combination &quot;dzs&quot; after the combination &quot;dz&quot; (i.e. &quot;foodzsbar&quot; should sort before &quot;foodzbar&quot; in Hungarian).

In Estonian, &quot;Z&quot; sorts as an equivalent to &quot;S&quot;.

Etc. etc. etc.

The suggested patch may be very appropriate for individual Wikimedia installations, but is not so as part of the proper fix.</pre>
    </div><div id="c161" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c161">Comment 161</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 17:12:17 UTC
        </span>
      </div>



<pre class="bz_comment_text" >utf8 support in MySQL supports a number of common languages, including Danish, Swedish, French, Hungarian, and Estonian:

<a href="http://dev.mysql.com/doc/refman/5.1/en/charset-unicode-sets.html">http://dev.mysql.com/doc/refman/5.1/en/charset-unicode-sets.html</a></pre>
    </div><div id="c162" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c162">Comment 162</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Huji</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 17:48:42 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c160">comment #160</a>)

Actually, I think the issues you raised with collations and languages has nothing to do with MediaWiki; if anything, MySQL is to be blamed. All we want here is for MediaWiki to use the full extent of collation features offered by MySQL. Perhaps not all languages will benefit from it, but at least some of them do, and that's enough a reason for a change like this.</pre>
    </div><div id="c163" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c163">Comment 163</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">T. Gries</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 21:47:56 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to comments #159 and #160)
<span class="quote">&gt; While the suggested patch clearly dramatically improves the page title sorting,
&gt; it doesn't make it 100% correct for all &quot;European languages&quot; though it may make it so for some, and I think it would be an improvement for all but the Nordic
&gt; languages.... Norwegians, and Swedes expect &quot;Ö&quot; to be treated as a separate letter that sorts after &quot;Z&quot;.</span >

Yes, I know this, too.

<span class="quote">&gt; The suggested patch may be very appropriate for individual Wikimedia
&gt; installations, but is not so as part of the proper fix.</span >

Thanks for pointing out. I must admit, that you are _fully_ right, also knowing of the collation differences. We developers should collaboratively think to find a satisfying solution for the &quot;collation problem&quot;.

This could be done in Berlin during the Wikimedia Developer Workshop 2010, held on April 14.-16. in Berlin, Germany, as part of the Wikimedia Conference 2010. <a href="http://techblog.wikimedia.org/2010/03/registration-open-for-the-developer-workshop-in-berlin/">http://techblog.wikimedia.org/2010/03/registration-open-for-the-developer-workshop-in-berlin/</a></pre>
    </div><div id="c164" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c164">Comment 164</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 22:06:57 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c163">comment #163</a>)
<span class="quote">&gt; Thanks for pointing out. I must admit, that you are _fully_ right, also knowing
&gt; of the collation differences. We developers should collaboratively think to
&gt; find a satisfying solution for the &quot;collation problem&quot;.</span >

The options I know of are:

1) Use MySQL collation support, just using utf8 everywhere.  This will mess up equality comparisons in ways we almost certainly don't want, doesn't support characters outside the BMP, etc.

2) Roll our own sortkeys.  Probably requires a lot more work, and a lot less efficient (need to keep extra column+index around in all relevant tables).  Also might be tricky, since the default Unicode algorithm gives very long sort keys, which we'd have to squish somehow (AFAIK).

3) Use some utf8 collation for cl_sortkey, but keep everything else binary.  We could also add an extra page_sortkey using utf8 collation, which is no more expensive than (2).  This sounds like the best option to me offhand.  It would be as easy to implement as anything here, and wouldn't have such bad side effects.  It would somewhat mess up pages with non-BMP characters in the name, though.</pre>
    </div><div id="c165" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c165">Comment 165</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">T. Gries</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 22:18:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c164">comment #164</a>)
<span class="quote">&gt; (In reply to <a href="show_bug.cgi?id=164#c163">comment #163</a>)
&gt; The options I know of are:
&gt; 1) Use MySQL collation support, just using utf8 everywhere.  This will mess up
&gt; equality comparisons in ways we almost certainly don't want, doesn't support
&gt; characters outside the BMP, etc.
&gt; 
&gt; 2) Roll our own sortkeys.  Probably requires a lot more work, and a lot less
&gt; efficient (need to keep extra column+index around in all relevant tables). 
&gt; Also might be tricky, since the default Unicode algorithm gives very long sort
&gt; keys, which we'd have to squish somehow (AFAIK).
&gt; 
&gt; 3) Use some utf8 collation for cl_sortkey, but keep everything else binary.  We
&gt; could also add an extra page_sortkey using utf8 collation, which is no more
&gt; expensive than (2).  This sounds like the best option to me offhand.  It would
&gt; be as easy to implement as anything here, and wouldn't have such bad side
&gt; effects.  It would somewhat mess up pages with non-BMP characters in the name,
&gt; though.</span >

Can you start writing an extension, which outputs the list of pages <a href="http://en.wikipedia.org/wiki/Special:AllPages">http://en.wikipedia.org/wiki/Special:AllPages</a> in a user-definable collation such as utf8_general_ci; utf8_unicode_ci; utf8_swedish_ci ? This would be a good starting point in my view.</pre>
    </div><div id="c166" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c166">Comment 166</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 22:30:03 UTC
        </span>
      </div>



<pre class="bz_comment_text" >This shouldn't be an extension, we may as well have a page_sortkey added in core.  Makes more sense there.  However, categories are lower-hanging fruit, since we just need to change cl_sortkey's collation -- the column already exists.  Plus, categories are more visible.  This needs a sysadmin either way, however, not just developers.</pre>
    </div><div id="c167" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c167">Comment 167</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">T. Gries</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-12 22:38:48 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c166">comment #166</a>)
<span class="quote">&gt; This shouldn't be an extension, we may as well have a page_sortkey added in
&gt; core.  Makes more sense there.  However, categories are lower-hanging fruit,
&gt; since we just need to change cl_sortkey's collation -- the column already
&gt; exists.  Plus, categories are more visible.  This needs a sysadmin either way,
&gt; however, not just developers.</span >

Sounds reasonable, ok, but who comes up with a sustainable solution for the core code and this buzilla ?</pre>
    </div><div id="c168" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c168">Comment 168</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-03-14 16:26:48 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Changing cl_sortkey to utf8 *is* a solution.  It needs a sysadmin to do it on Wikimedia (if we want to do it), and we'd probably also want some core code to filter out non-BMP characters before they get to the sortkey.</pre>
    </div><div id="c169" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c169">Comment 169</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Liangent</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-05-14 15:33:03 UTC
        </span>
      </div>



<pre class="bz_comment_text" >[[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=mw%3AExtension%3ACategoryMultisort">mw:Extension:CategoryMultisort</a>]] and [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=mw%3AExtension%3ACategoryMultisortChinese">mw:Extension:CategoryMultisortChinese</a>]] written by me is expected to resolve the problem on Chinese Wikipedia.</pre>
    </div><div id="c170" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c170">Comment 170</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tim Starling</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-06-02 00:48:00 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I think using ICU sort keys, possibly with a pure PHP port to support non-WM installations, would be a good way to go. It would support all the languages we want to support, which is important.</pre>
    </div><div id="c171" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c171">Comment 171</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-21 21:03:40 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'll be working on this bug.  I hope to have a solution coded up within a couple of weeks.  I wrote a post to wikitech-l about it, and encourage people to respond there rather than here (since this involves several bugs):

<a href="http://lists.wikimedia.org/pipermail/wikitech-l/2010-July/048399.html">http://lists.wikimedia.org/pipermail/wikitech-l/2010-July/048399.html</a>

I'll also note that the enormous amount of bickering and repetition here meant that I wound up skimming it, so if I missed your suggestion, please repeat it on the wikitech-l thread.</pre>
    </div><div id="c172" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c172">Comment 172</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 06:00:34 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt;&gt; But if the SQL engine does not have such support, this must be implemented in
&gt;&gt; the PHP code and collation keys can be stored in a new datacolumn (the extra
&gt;&gt; data column can be added or filled conditionnally : if the SQL engine supports
&gt;&gt; the needed collations, this column can remain NULL to save storage space).
&gt;&gt; 
&gt;If you sort this stuff in PHP, you need to grab the entire list before you can
&gt;reliably sort it. Doing that for [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3ALiving%20people">Category:Living people</a>]] has no chance of
&gt;staying within the memory limit.</span >

And this was false. Because you assume that the generation of sort keys has to be done on database queries for listing the content of a category, when instead this generation os sortkeys can be done safely only on database inserts/updates for each separate page.

What I wanted to say is that the computed sortkeys will have to be stored. But several sort keys for the same page in the same category are possible (one for each collation locale indicated by the target category).

There will be no memory limit, but of course this will have a storage cost, as the stored sort keys will have to be queried along with the list of pages to display. 

The good question to ask is: where do we store these sortkeys? Currently we have a SQL relation table containing a unique index on (categoryID, sortkey, pageID) and this is enough to perform the join with the table of pages. However thre's still only one sortkey per page and per category.

That sortkey is needlessly using the pageID within the generated sortkey (this is is visible when crossing a page limit and navigating throught pages) so in fact the unique index is on (categoryID, &quot;augmented sortkey&quot;). Conceptually wrong and bogous (I think this was just a fast patch when there were unicity problems and multiple pages could be specified with the same sortkey).

What is limiting you of changing the relation table containing the list of pages in categories, of using instead a unique index on:
 (categoryID, sortkey, pageID, localeID)
where the localeID is one of the locales supported by the project, which specifies: the language for which a collation is being performed, and a collation variant (for example, in Chinese, sort by radical/strokes with locale=&quot;zh-Hans&quot;, or sort by pinyin with locale=&quot;zh-Latn&quot;)

The generation of the concent of the sortkey column is the only major problem requiring a design decision. This is where it should not even depend on the SQL engine, and where it can be implemented within PHP, using the PHP extension that allows using ICU functions. That string does not have to be extremely long and does not have to be be humane readable.

It can be safely be stored with a reasonnable length limit. So ICU-generated sortkeys are still safe if they get truncated. Notably because the unique index on:
 (categoryID, sortkey, pageID, localeID)
is also unique on its restriction:
 (categoryID, pageID, localeID)
And the sortkey generated by ICU, even if it's a string of binary bytes can still safely be stored in a table index that does not support blobs but want only &quot;VARCHAR(n)&quot; types, by serializing the binary sortkey to a safe encoding (the most basic that will work is hexadecimal) that does not even require the support of Unicode or UCA collation. Just use an ASCII only column to store the computed binary sortkey serialized as an ASCII-only string.

But if the database engine supports strings of bytes, just don't serialize the blob, use the supported SQL type that can store it directly, for example VARBINARY(n), if it remains sortable in binary order.

With this design, you are completely independant of the SQL engine, it will work identically on MySQL, PostrgresSQL, or others. And you'll have solved the problems of collation with multiple locales according to their rules, and possibly according to visitors preferences.

Note: above, the localeID is not directly a VARCHAR(n) containing &quot;en&quot;, or &quot;zh-Hans&quot;. It is an arbitrary unique numeric identifier that maps in fact to a collation rule within a locale, and this collation rule may need to be updated from time to time: when upgraded a collation, you'll generate additional keys with a new localeID. And when this is done the table of supported collations will indicate which localeID is the current one to use, and you'll be able to perform easiky the cleanup of old sortkeys that where computed within the old rule.

It's not a complicate design, and it offers stability warranties and supports as well the possibility of upgrading the collations.

The possibility of offering multiple sortkeys for the same page in the same category comes as a bonus, and you can assign &quot;localeID=0&quot; to store the user-specified sortkey that has been assigned in a page using the second parameter of the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3Apagename">category:pagename</a>|sortkey]] link or the parameter of the {{DEFAULTSORT:sortkey}} if this paramter was missing (this will avoid having to reparse the pages just to retrieve this user-specified sortkey).</pre>
    </div><div id="c173" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c173">Comment 173</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 07:15:01 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c172">comment #172</a>)
<span class="quote">&gt; And this was false. Because you assume that the generation of sort keys has to
&gt; be done on database queries for listing the content of a category, when instead
&gt; this generation os sortkeys can be done safely only on database inserts/updates
&gt; for each separate page.
&gt; 
&gt; What I wanted to say is that the computed sortkeys will have to be stored. But
&gt; several sort keys for the same page in the same category are possible (one for
&gt; each collation locale indicated by the target category).
&gt; </span >
[etc., etc., etc.]

I suggest you read <a href="show_bug.cgi?id=164#c171">comment #171</a> and the wikitech-l thread linked from there. That thread is an implementation proposal by Aryeh, who, unlike pretty much everyone else commenting on this bug (myself included), is actually gonna start implementing it; he suggested he might start today. This bug already has 173 comments, and posting more long comments about hypothetical implementations while not replying to the implementation plan of the one person actually being serious about getting this done is not useful and might just push this bug to 200 comments without getting anywhere. If we're gonna discuss anything, let's discuss the current implementation plan: it is the only relevant plan to discuss at this point.</pre>
    </div><div id="c174" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c174">Comment 174</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 09:13:30 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt; If we're gonna discuss anything, let's</span >
discuss the current implementation plan: it is the only relevant plan to
discuss at this point.

This is EXACTLY what I was discussing: proposing an implementation design, which also considers the fact that collations will also need to evolve over time (for example the UCS repertoire is evolving (so the DUCET table is modified), and collation rules are being corrected for some languages, in the CLDR project) : each change will generate a new internal localeid to support it, and there will be possibly different keys during the transition, even if (finally) an old collation rule will be deleted (with its old sortkeys) after the new sortkeys will have been fully recomputed.

So this is clearly not &quot;blah blah&quot;. And this is certainly relevant for the fact that you're considering implementing some or all of the suggestions (and you'll have to test your solutions, including on their performance impact.

I propose a simple model that can be very space-efficient, and that also avoids reparsing all pages if ever a collation rule is changed, or if additional collation rules are added in a category to support multiple sort orders (notably within Chinese categories that could support different orders).

My proposal does not even depend on the backend SQL server capabilities (all it has to support is at least a binary order on ASCII-only VARCHAR(n) to store the computed and truncated sortkeys, that will be generated by the PHP front-end (using ICU) and followed by an ASCII-only serialization. This means that the simplest &quot;ORDER BY&quot; queries to retrieve correctly ordered lists of pages will work independantly of the backend.

The function used in PHP to generate the binary-ordered sortkey (that will finally be effectively stored) should also be accessible in MediaWiki as a builtin parser function, that will take two parameters: the locale code, and the text.

For example, as {{SORTKEY:text|locale}}, where the ''locale'' specified can be optional and will take the default value of the {{CONTENTLANGUAGE}} of the project).

This builtin parser function could also be used to correctly sort the sortable Mediawiki tables inserted in articles, by using correct sortkeys generated by this template, if the generated sortkey is readable and effectively serialized as ASCII-only, but it does not necessarily have to be truncated by this function, even if it will be truncated when the same function result will be used to store sortkeys in the schema).

This parser function should even be the first development to realize, before even changing the category-page indexes, because it can be applied and tested immediately in existing categories (for example by using categorizing templates in Wiktionary), without even upgrading the SQL schema.</pre>
    </div><div id="c175" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c175">Comment 175</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 09:59:32 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c174">comment #174</a>)
<span class="quote">&gt; &gt; If we're gonna discuss anything, let's
&gt; discuss the current implementation plan: it is the only relevant plan to
&gt; discuss at this point.
&gt; 
&gt; This is EXACTLY what I was discussing: proposing an implementation design,</span >
AFAICT you're proposing your own design without mentioning where it differs from or coincides with Aryeh's proposal. From briefly reading your latest comment, it looks like a lot of what you're proposing is already in Aryeh's proposal, such as the binary-ordered sortkey thing. Other things, such as the attention you're paying to the possibility that collation rules may change, are not covered in Aryeh's proposal, so those are valuable additions.

So you're right, it's certainly not &quot;blah blah&quot;, but it would help a lot if you limited your comments to the differences between your and Aryeh's proposal, rather than leaving it up to the reader to find and filter the parts the two proposals have in common.</pre>
    </div><div id="c176" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c176">Comment 176</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 10:04:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Anyway, the Aryeh's proposal is not found or documented at the location you indicate. It just says that he will try to work on it today and still asks for solutions and asks for questions that are unanswered in his comment on the wikitech-l list.

In a similar spirit, the generation of the section heading for categories could
also be a different builtin parser function such as:

: {{COLLATIONMAP:text|locale|level|clusters}}

with the similar parameters, and clusters=1 be default (more below). It will
return a non-opaque string that can be displayed in category pages, and could
even become a valid anchor for searching starting at some text position in the
list (ordered using the specified locale). It should be only a level-1
collation mapping by default (only level 1 will be considered for displaying
headings, however some categories could later specify another default collation
level for such mapping.

Note that collation-based mappings is a VERY different concept from the concept
of collation-based sortkeys (read the Unicode UCA specification): sortkeys are
opaque and intended to generate a full order of texts, mappings are readable
but only intended to produce a partial order.

Another optional parameter could be given after the collation level, to
indicate how many locale grapheme clusters should be included in the heading.
The default 
 headings in categories should just use 1 grapheme cluster from the text given
to the first parameter of {{COLLATIONMAP:text|locale|level|clusters}} (more
below).

In a category you could *LATER* specify additional sort orders (and collation
mappings at the same time) using a syntax like:
{{SORTORDER:locale|level}} (the default collation level will be 1 for
categories).

Example 1: in a Chinese category page, you could specify:
; {{SORTORDER:zh-hans}}
: to indicate that pages in that category will be also available using the
radical/stroke order of sinograms. 
; {{SORTORDER:zh-latn}}
: to indicate that pages in that category will be also available using the
Pinyin Latin order.

Example 2: in a Korean cateogry, where the primary order is based on the
decomposition into &quot;jamos&quot;, it will be enough to specify:
; {{SORTORDER:ko}}
: (for the default South Korean order of jamos)
; {{SORTORDER:ko-kp}}
: (for the default North Korean order of jamos)

Indicating the collation level with a value different from 1 could generate sub
headings for level 2, but I think it should only display them with the
specified level, all using the same heading from the level-2 collation mapping.

Indicating clusters=2 (or more) in the builtin parserfunction {{COLLATIONMAP:}}
may be used to generate more precise headings (for example in heavily English
or French populated categories, use 2 grapheme clusters to generate headings on
the 2 first letters, but keep the collation level to 1). By default the builtin
parser function will not limit the number of grapheme clusters (so it will
remap all the text), but a category could still specify this maximum number of
clusters to consider for headings.

By default a category will consider either
* clusters=1 : section headings will be generated only for the first cluster
(this is what is currently used in categories). or
* clusters=0 : section headings will not be generated at all.
(this default could be a per-project default).

The generation of section headings (using the same PHP function used by
{{COLLATIONMAP:}}) does not require any modification of the schema. Headings
can be computed and generated on the fly, from the retrieved list of pages.
Headings should not even influence the sort order, they are just convenient
groupings for display.

The {{COLLATIONMAP:}} function described here would in fact enter in the list
of string builtin function, as it falls in the same category as other mapping
functions like {{UC:}} or {{LC:}}. This is just another mapping.

The generation of sort keys (using the same PHP function used by {{SORTKEY:}})
however requires active parsing to store them in the schema. So it can only be
done later. This developement should be made *later* (when the SQL schema for
category indexes will be adjusted to support multiple/upgradable collation
orders).

So yes, a builtin parser function such as
{{COLLATIONMAP:text|locale|level|clusters should first be implemented and
tested separately before being used to group items in category headings, but it
can be implemented separately from the developement and deployment of the SQL
schema for indexing categories with {{SORTKEY:}}), and integrated later in the
code that will present the list of pages to the users.</pre>
    </div><div id="c177" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c177">Comment 177</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 10:17:54 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c176">comment #176</a>)
<span class="quote">&gt; Anyway, the Aryeh's proposal is not found or documented at the location you
&gt; indicate. It just says that he will try to work on it today and still asks for
&gt; solutions and asks for questions that are unanswered in his comment on the
&gt; wikitech-l list.
&gt; </span >
He does document a fair bit of what he wants to do (e.g. separating files, categories and regular pages with sortkey prefixes). It's not a complete proposal and he is asking for input, but he hasn't left everything open either.

Also, why keep the discussion in two places? Why not join the discussion on wikitech-l?</pre>
    </div><div id="c178" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c178">Comment 178</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 10:48:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Because his specification is really incomplete, and he said that <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Support collation by a certain locale (sorting order of characters)"
   href="show_bug.cgi?id=164">Bug#164</a> was useless (despite of the fact that I had described my solution extensively in <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Support collation by a certain locale (sorting order of characters)"
   href="show_bug.cgi?id=164">Bug#164</a>long before Ariyeh started working on it.

And yes, before ever attempting to change the schema, I support the prior developement and extensive testing of builtin parser functions supported by PHP functions which will be shared later to support the updated SQL schema.

Only this developmeent alone will have significant difficulties:
* notably integrating ICU in a PHP module installation, or
* rewriting the collation algorithms entirely with PHP;
* having to support the DUCET updates caused by new Unicode versions or corrections;
* having to support multiple collation orders by per-locale tailorizations (coming from CLDR or from other sources).

The need to support upgraded collation orders is also an important decision factor for the schema, if sortkeys are stored in a SQL backend, that's why I speak about it very early:
* collations supported by SQL backends have very strong limitations, or any upgrade would require shutting down the servers for hours or days to perform the upgrade of collated indexes.
* in their missing full ISO 10646 &quot;level 3 implementation&quot; for the support of supplementary planes.

All this is something that can be avoided completely by using ICU and not depending on SQL backends for their support of many more collation locales that we need in our international projects:

* the schema just needs to be able to store multiple sortkeys, so that newer sortkeys (computed with the new rules) can be progressively computed in the background by a bot or server script or some upgrades occuring on the fly when processing articles.
* older sortkeys that were using a older generation rule can be deleted in a simple DELETE operation after the new collation rule for a corrected locale has been made the default one, or can be deleted one by one each time a new generation sortkey is recomputed and has been inserted (there's not even the need to perform the two sucessive operations in a transaction if the first INSERT withe the new rule has been sucessful).

Because we have now multiple sortkeys per indexed page in a category, we can conveniently support multiple sortkeys for different locales and offer a good experience for users that will want alternate sort orders (notably Chinese users that will want presentations in radical/stroke order, or in pinyin order).

----

Another note about how to serialize the opaque sortkeys:
the builtin function {{SORTKEY:text|locale|level}} described above will not
limit the length of the generated binary sortkey, however it should serilize it
in a valid Unicode text that can be used in tables.

A convenient serialization of bytes to characters that will sort correctly is
Base-36 using the alphabet [0-9A-Z] (no padding necessary) or Base-32 (it
avoids modular arithmetics but will serialize into longer strings)

If sortkeys are about to be stored, retrieved in the SQL schema, and sorted by
the SQL clause &quot;ORDER BY...sortkey...&quot;, then:

- either the SQL backend allows storing and sorting binary sequences of bytes
as VARBINARY(N) : then no extra serialization is needed, store directly that
opaque sort key, after truncation to the max length value (N) indicated in the
SQL type of the &quot;sortkey&quot; table column.

- or the SQL backend does not support sortable binary sequences of arbitrary
bytes, but can only sort VARCHAR(N), then use a similar Base-32 or Base-36
conversion to create compatible sortkeys, and then store the converted string
after truncating to the max length value (N) indicated in the SQL type of the
'sortkey&quot; table column.

- in both cases, the stored sortkeys will NEVER be exposed to users, its sole
purpose is to make the SQL &quot;ORDER BY&quot; clause work properly.

To start listing a category from a given artbitrary Unicode text, use the
&quot;start=&quot; HTTP query parameter and compute internally the sortkey associated
with it to generate the value used in SQL clause &quot;WHERE sortkey &gt;= 'value'&quot;.

- Section headings in categories will never need to be stored, they are
generated on the fly by reading the page names retrieved in the SQL result set
using the {{COLLATIONMAP:}} function, with the specified locale in the
&quot;uselang=&quot; HTTP query parameters, and the specified (or default) &quot;clusters=&quot;
parameter (whose default will be 1 or 0 as indicated above). They will be
diretly readable by users and do not require decoding anything from the stored
sortkey.

- the readable collation mappings and the opaque sortkeys should be coherent in
the same locale, but they are clearly different: pagenames that are
collation-mapped should sort in the same natural order as the section headings
generated from them, so it's absolutely not needed to generate sort keys from
collation-ampped headings computed in the fly.</pre>
    </div><div id="c179" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c179">Comment 179</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 11:16:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c178">comment #178</a>)
<span class="quote">&gt; All this is something that can be avoided completely by using ICU and not
&gt; depending on SQL backends for their support of many more collation locales</span >
This is exactly what Aryeh is proposing. I think everyone agrees that it's better to use binary sorting with munged sortkeys rather than SQL backends' half-baked collation support, so you don't need to argue that.

<span class="quote">&gt; - Section headings in categories will never need to be stored, they are
&gt; generated on the fly by reading the page names retrieved in the SQL result set
&gt; using the {{COLLATIONMAP:}} function, with the specified locale in the
&gt; &quot;uselang=&quot; HTTP query parameters, and the specified (or default) &quot;clusters=&quot;
&gt; parameter (whose default will be 1 or 0 as indicated above). They will be
&gt; diretly readable by users and do not require decoding anything from the stored
&gt; sortkey.
&gt; </span >
This is not that simple, as was pointed out on wikitech-l: what if you've got a language where á sorts the same as a (that is, a and á are the same for sorting purposes), then your sorted result could look like:

Áa
Áb
Ac
Ád
Ae
Af
Ág
...

We humans understand that the proper heading for this is &quot;A&quot;, not &quot;Á&quot;, but how will the software know that? Even if we store the original, unmunged sortkeys (note that the sortkey is not necessarily equal to the page name: [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Albert%20Einstein">Albert Einstein</a>]] sorts as &quot;Einstein, Albert&quot;) so we can differentiate A from Á, we can't just take the first or even the most frequent letter: neither is accurate in this case.</pre>
    </div><div id="c180" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c180">Comment 180</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 11:42:55 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Your issue ***IS*** addressed in my proposal:

*Both* {{COLLATIONMAP:Áa}} and {{COLLATIONMAP:Aa}} will be unambiguously &quot;aa&quot; in the primary collation level for that locale. They only differ at the secondary collation level (with accents).

You did not understand that a collation-mapping is DIFFERENT from an opaque sort key, even if both are built using the same collation rules for the same locale.

The case of &quot;Albert Einstein&quot; sorting as &quot;Einstein, Albert&quot; will pass through the standard generation of the sortkey from the string &quot;Einstein, Albert&quot; explicitly given in MediaWiki source code as the parameter of the {{DEFAULTSORT:Einstein, Albert}} special function or as the second parameter of the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|Einstein, Albert]] link.

----

So here is a development and deployment map:


1) Develop to PHP functions that will compute:

  function sortkey($text, $locale, $level=1)
    - it will return an opaque array of byte values
    - $locale may be given a default value from the project's content language, but this is not specified here but part of its integration in MediaWiki
    - $level may take the default value of 1.
    - the algorithm involves parsing steps to transform the $text parameter into normalized form, then parse it by collation element, and then locating the collation element in the tailored collation table, which is indexed by collation element value and returns an array of collation weights, one for each level.
    - it packs all the collation weights into the returned opaque array of byte values, by appaending all non-zero collation weights for each collation element at the same collation level before appending the collation weights for higher successive levels.
 
  function collationmap($text, $locale, $level=1, $clusters)
    - it will return a remapped text using the same $locale and $level parameters
    - it will use the same DUCET table and the same per-locale tailorings
    - the same parsing steps are performed
    - but instead of packing the collation weigths, it scans the collation table in the reverse order, by locating the first collation element (a small Unicode string, often limited to a single character) that has the same collation weights up to the specified level. When this smallest collation element is found, append this to the result string.

  function base36($bytes)
    - it packs the opaque binary array of bytes into plain ASCII that has safe binary order and can be safely be stored in a VARCHAR(N) table field, or that can be returned in a MediaWiki function.

  This module should use ICU and implement the locale tailorings, and should be able to support a full DUCET table,and allow lookups from a collation element to an array of collation weights, or the reverse (and ordered) lookup from a collation weight to a collation element for the function collationmap())

2) Integrate these functions in a Media Wiki extension for builtin parser functions.

  {{SORTKEY:text|locale|level}}
    - this will return base36(sortkey($text, $locale, $level))
    - by default take $level=1
    - by default take $locale={{CONTENTLANGUAGE}} (or {{int:lang}} ?)
    - it can be used as a much better implementation of Wikipedia templates like [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Template%3ASort">Template:Sort</a>]]

  {{COLLATIONMAP:text|locale|level|clusters}}
    - this will return collationmap($text, $locale, $level, $clusters)
    - it can be used to simulate the generation of headings in categories, but as well within mediawiki tables
    - by default take $clusters=null (no limitation of length)
    - by default take $level=1
    - by default take $locale={{CONTENTLANGUAGE}} (or {{int:lang}} ?)


3) build a function for mapping category sortkeys into stored sort keys, this will depend on the SQL backend capabilities and on the schema constraint length for the sortkey data columns:

   function sqlsortkey($text, $locale, $level)
     - it will return either :
        substring(sortkey($text, $locale, $level), 0, $maxlength)
     - or :
        substring(base36(sortkey($text, $locale, $level)), 0, $maxlength)
     - the choice will depend on the support of VARBINARY(N) and its sortability  in the SQL engine, or of only VARCHAR(N)
     - the sortkey will not have to be UTF-8, and will not need any support of the same locales for collation tailoring in the SQL backend.

4) update the schema to support the description of supported internal collation ids.
   - add a mapping function from the human readable $locale parameter to the collation id associated to the curent version of the collation rule currently applicable to a locale.
   - support this mapping with a simple &quot;collations&quot; relational table

5) build a new category index based on:
  (categoryid, collationid, sortkey, pageid)
  - categoryid and pageid are standard MediaWiki page ids (in any modification version).
  - collationid will come from the previous mapping (using the locale identifier string, and where the locale will be determined by HTTP query parameters like &quot;uselang=&quot;, i.e. {{int:lang}}, or from the project's default {{CONTENTLANGUAGE}}).
  - the sortkey column will be computed using PHP's:
    sqlsortkey($text, $locale, $level)
    described above.

....</pre>
    </div><div id="c181" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c181">Comment 181</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 11:55:26 UTC
        </span>
      </div>



<pre class="bz_comment_text" >But effectively, we would even be smarter for category indices, by separating the namespaces, so that they will be paginated and navigatable independantly (this means that namespaces will have their own prefered sort order, specified in the project, but this should not require any complex computing of sortkeys: we already have namespace ids that sort naturally in numerical order)

This means that an extended category index would be:
(categoryid, collationid, sortkey, namespaceid, pageid)

Namespaces should have never been included at all in the computation of the default sortkeys, so instead of using the default sortkey from {{FULLPAGENAME}} (the way it is today), it should just use {{PAGENAME}}.

... Unless a category specifies specifically that it wants to mix the various namespaces, in which case the namespace name will be part of the default sort key, and the namespaceid will become 0 in all pages categorized in that category.

This is a decision factor for the last steps of the development plan above, it should not influence the development of the 2 first steps above.</pre>
    </div><div id="c182" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c182">Comment 182</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 13:18:28 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that my developement plan will NOT imply an immmediate change of the SQL schema. At first, if only working on the frist 2 steps, no schema change is necessary to effectively test the two functions.

Notably, you'll be able to create test pages containing lists of words formatted as table rows using a template. You'll be able to show the words, in one column, then the opaque (base-36 converted) sort keys in another column, and then the visible collation-mapped string in a third column.

Then you'll include this list within a page adding the table headers and using the existing &quot;sortable&quot; table class to see how they collate when sorting by the second column, and you'll also be able to sort again on the third column, to see that the collation-mapped string will not alter this sort order.

If all this passes, this can be deployed and immediately used in Wiktionnary (notably French Wiktionnary) for sorting categories containing huge lists of words, or in english Wiktionnary for use in the template that generate sort keys for people's &quot;Last name, first name&quot;.

This will be already a considerable progress, even if there will be no immediate support for multiple sort orders (in Chinese).

The change of schema, where the {{defaultsort:sortkey}} parameter or the second parameter of the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3Apage">category:page</a>|sortkey]] link will be used effectively, so that we no longer have to use a sortkey parameter in pages and templates can be delayed a lot.

But the two developed functions (at least the first one {{SORTKEY:text|locale|level}} which is a bit simpler to implement than the second one {{COLLATIONMAP:text|locale|level}} that is a bit trickier as it requires special handling for collation elements that are mapped to more than 1 collation weight per level) should be a lot simplified, and will be enough tested before even thinking about reusing them for sorting pages in categories and presenting the lists with headings.

There is a separate modification to develop for grouping category contents by namespace. This should be developed and deployed first before even trying to change the schema for sort keys.

In fact, the first integration for displaying categories will be to use {{COLLATIONMAP:}} internally for displaying the headings in category pages. This won't require any change as well for the SQL schema.

Finally, the use of {{SORTKEY:}} and the addition of new keywords for use in category pages, that will allow a category to support multiple collations, will happen only at the last step. Because this is the most sensitive one and this is the only step that may finally involve a change of schema. There's much enough work to do for building all the first integration steps, as extensive tests in various locales will be needed, so that all wikis report their problems with the implemented collations and their supported tailorings.</pre>
    </div><div id="c183" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c183">Comment 183</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 17:57:42 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Okay, look, if you make posts this long I'm not going to be able to read them.  You have to state your points briefly and clearly, or else I'm just not going to have time to read through carefully and figure out exactly what you're trying to say.  Walls of text are really not helpful.

Furthermore, you're focusing too narrowly on implementation details, like the exact interface a function should implement.  Please try to state your concerns primarily in terms of use-cases or problems -- scenarios that the implementation will need to handle.  Secondarily, it's fine if you propose specific solutions, but I can't evaluate your solutions unless you state clearly what problems they're trying to solve.

I'll comment on a few things you said.  If I miss anything important, please restate it *briefly*, and I can address that too.

(In reply to <a href="show_bug.cgi?id=164#c172">comment #172</a>)
<span class="quote">&gt; What I wanted to say is that the computed sortkeys will have to be stored. But
&gt; several sort keys for the same page in the same category are possible (one for
&gt; each collation locale indicated by the target category).</span >

If we store separate sortkeys per category link per locale, it would take vastly too much space, since there are likely to be dozens of locales.  categorylinks is already a big table; we can't justify making it ten times bigger for this.  Each category can have one locale and only one locale.

<span class="quote">&gt; That sortkey is needlessly using the pageID within the generated sortkey (this
&gt; is is visible when crossing a page limit and navigating throught pages) so in
&gt; fact the unique index is on (categoryID, &quot;augmented sortkey&quot;). Conceptually
&gt; wrong and bogous (I think this was just a fast patch when there were unicity
&gt; problems and multiple pages could be specified with the same sortkey).</span >

It is not needless.  We need a unique key to sort by, or else paging doesn't work if many pages have the same sort key (e.g., if it was manually assigned).  See <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - &quot;Next 200&quot; link in category page broken"
   href="show_bug.cgi?id=4912">bug 4912</a>.

<span class="quote">&gt; The generation of the concent of the sortkey column is the only major problem
&gt; requiring a design decision. This is where it should not even depend on the SQL
&gt; engine, and where it can be implemented within PHP, using the PHP extension
&gt; that allows using ICU functions. That string does not have to be extremely long
&gt; and does not have to be be humane readable.</span >

Yes, we will certainly use ICU or something.  GerardM has said he much prefers CLDR, so maybe we'll use that instead.

<span class="quote">&gt; It can be safely be stored with a reasonnable length limit. So ICU-generated
&gt; sortkeys are still safe if they get truncated. Notably because the unique index
&gt; on:
&gt;  (categoryID, sortkey, pageID, localeID)
&gt; is also unique on its restriction:
&gt;  (categoryID, pageID, localeID)
&gt; And the sortkey generated by ICU, even if it's a string of binary bytes can
&gt; still safely be stored in a table index that does not support blobs but want
&gt; only &quot;VARCHAR(n)&quot; types, by serializing the binary sortkey to a safe encoding
&gt; (the most basic that will work is hexadecimal) that does not even require the
&gt; support of Unicode or UCA collation. Just use an ASCII only column to store the
&gt; computed binary sortkey serialized as an ASCII-only string.
&gt; 
&gt; But if the database engine supports strings of bytes, just don't serialize the
&gt; blob, use the supported SQL type that can store it directly, for example
&gt; VARBINARY(n), if it remains sortable in binary order.
&gt; 
&gt; With this design, you are completely independant of the SQL engine, it will
&gt; work identically on MySQL, PostrgresSQL, or others. And you'll have solved the
&gt; problems of collation with multiple locales according to their rules, and
&gt; possibly according to visitors preferences.</span >

This was always the intended design.  (But note that truncating these sort keys might not always be fully safe: it could cause tons of collisions, depending on the nature of the sort key generation algorithm.  These would be resolved arbitrarily, by page_id, which is confusing to users.)

<span class="quote">&gt; It's not a complicate design, and it offers stability warranties and supports
&gt; as well the possibility of upgrading the collations.</span >

Upgrading the collation can be done in-place.  The worst case is that categories sort weirdly for a few hours.  Also, we would only realistically have to change the collation often on smaller wikis, since the largest wikis should have high-quality collations that cover almost all their pages to begin with.  I don't think we need to adjust the schema to prepare for this.</pre>
    </div><div id="c184" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c184">Comment 184</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 18:40:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c183">comment #183</a>)
<span class="quote">&gt; It is not needless.  We need a unique key to sort by, or else paging doesn't
&gt; work if many pages have the same sort key (e.g., if it was manually assigned). 
&gt; See <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - &quot;Next 200&quot; link in category page broken"
   href="show_bug.cgi?id=4912">bug 4912</a>.
&gt; </span >
It is needless in the sense that the cl_from field is right there and is indexed. We should just be using that field rather than tacking its contents onto the sortkey because we're too lazy to rewrite IndexPager so it can handle paging by more than one field (which is not very hard).</pre>
    </div><div id="c185" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c185">Comment 185</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-22 18:47:23 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Oh, I didn't get what he was saying.  Yes, obviously we should use the actual cl_from field, not tack it onto cl_sortkey (is that what we do these days?).  I'm going to have to make a lot of changes to the category pager anyway to support paging by multiple things, so I can do that while I'm at it.</pre>
    </div><div id="c186" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c186">Comment 186</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-24 05:53:30 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c183">comment #183</a>)
<span class="quote">&gt; Upgrading the collation can be done in-place.  The worst case is that
&gt; categories sort weirdly for a few hours.  Also, we would only realistically
&gt; have to change the collation often on smaller wikis, since the largest wikis
&gt; should have high-quality collations that cover almost all their pages to begin
&gt; with.  I don't think we need to adjust the schema to prepare for this.</span >

That'a a bad assumption : even the highest quality collations will need to be updated from time to time:
- Unicode evolves and new characters get encoded (new versions are published about every 1-2 years after synchronization and final balloting at both ISO WG2 and the UTC.
- The content of the Unicode DUCET is NOT stable: characters are inserted in the sequence so that the full list of collation weights needs to be offseted where the new characters get inserted.
- Collations for languages get corrected. We should be able to upgrade these rules when the CLDR project produces new tailorings (CLDR updates are published separately, about every 1-2 years.)

These corrections may be rare (every few months), but when they will occur, any upgrade could take many hours that could horce the site to go offline when recomputing sortkeys, or NO correction will be possible. Upgrading &quot;in place&quot; is effectively what I proposed, but how will you track which pages need to to reindexed?

A collation ID in the stored index can really help determine which collation rule was used to generate the stored sortkey; In addition it will allow to support multiple collations. This is the mean by which the &quot;in place&quot; recomputing can be safely be done.

Note: truncating the sortkeys will ALWAYS be needed, just because the database column will still have a length limit. Truncating is not so bad anyway, because:
- the compact binary sequence of primary collation weights, that starts the sort key will be at the begining of the sort key. Further length is used to store the compacted sequence of secundary collation weights, then the sequence of ternary collation weights.
- if truncation occurs, the effect will be that only the smallest differences will not be represented.

But if you accept to store only non-truncated sort keys, you'll still have the case where some pages will have some long name, plus the case where someone will have indicated for that page a very long {{DEFAULTSORT:sortkey}} or very long text in the second parameter of [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]]. To avoid this:
- page names already have a length limit. This also limits the length of sort keys computed from only them
- we should already truncate the string given in {{DEFAULTSORT:sortkey}} or {{category:..|sortkey]] so that the concatenation of this string and of the page name can be used to compute the binary sortkey.

If you can accept arbitrary lengths, so go with it, but it will be unsafe and your schema will not be able to put that in a sortable column (you'll be only able to put it in a referenced BLOB, just like the the text of articles, and databases can never sort external BLOB's)

Anyway you did not reply to the idea of first developin the parser functions and test them. Developping the SQL schema extension should not be attempted before at least the first function {{SORTKEY:text|locale|level}} has been fully developed and tested on specific pages (it can be tested easily in tables).

And with just this function, it should be possible on specific wikis to use it immediately to sort specific categories (for example by using templates using that function).

The second function {{COLLATIONMAP:text|locale|level|clusters}} is not needed immediately to develop the schema, but will be useful to restore the functionality of headings. Headings don't need to be stored as they can be computed on the fly, directly by reading sequentially the sorted result set from the SQL query:

You can compute headings from the returned page names, or from the existing stored &quot;cl_sortkey&quot; which should be used now ONLY to store the plain-text specified in articles with {{DEFAULTSORT:sortkey}} and [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]].
The existing cl_sortkey is just a forced &quot;hint&quot;, it does not make the sort order unique. Otherwise it should remain completely empty with the new schema. It will always be locale neutral and will take precedence on the page name : to sort the pages effectively, the content of the cl_sortkey content and the pagename should be always concatenated inernally to compute the binary sortkey for various  locales.</pre>
    </div><div id="c187" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c187">Comment 187</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-24 06:17:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c185">comment #185</a>)
<span class="quote">&gt; Oh, I didn't get what he was saying.  Yes, obviously we should use the actual
&gt; cl_from field, not tack it onto cl_sortkey (is that what we do these days?). 
&gt; I'm going to have to make a lot of changes to the category pager anyway to
&gt; support paging by multiple things, so I can do that while I'm at it.</span >

This does not require any change in the schema. This can be made immediately by MediaWiki developers and will not influence the developement of all corrections needed for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Support collation by a certain locale (sorting order of characters)"
   href="show_bug.cgi?id=164">bug #164</a> itself.

The unique index just has to include the cl_from field (whatever it contains, it is already the unique ID of the page, and it is already stored). Only the SQL queries and the HTTP requests have to be able to specify this cl_from field separately.

Tacking it in the sortkey was a bad decision made by &quot;lazy&quot; developers before they realized that storing a separate cl_from field was necessary. It just polluted the indexes and had the bad effect of truncating more precious space for correctly sorting some pages.

Drop this tacking immediately in the PHP code: the cl_sortkey is only intended to store the clear-text sortkey &quot;hint&quot; specified in {{DEFAULTSORT:sortkey}} or [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]] to override the sort order, and this clear-text sortkey is not really a true sortkey but a sort hint to override the default sort order. 

For example in people's names whose page name is &quot;FirstNames LastName&quot; but that we want to sort as if they were &quot;LastName, FirstNames&quot; by indicating only {{DEFAULTSORT:LastName !}} (it should not needed to include the FirstNames in the wiki text, as this sort hint will not be unique and the group of pages using the same hint will still need to sort within this group using their natural order). Even in that case, there's no need to bogously tack the cl_from field in the stored field.</pre>
    </div><div id="c188" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c188">Comment 188</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-24 07:00:47 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c183">comment #183</a>)
<span class="quote">&gt; Okay, look, if you make posts this long I'm not going to be able to read them. 
&gt; You have to state your points briefly and clearly, or else I'm just not going
&gt; to have time to read through carefully and figure out exactly what you're
&gt; trying to say.  Walls of text are really not helpful.
&gt; 
&gt; Furthermore, you're focusing too narrowly on implementation details, like the
&gt; exact interface a function should implement.</span >

An &quot;interface&quot; function is DEFINITELY NOT an &quot;implementation&quot; detail. My <a href="show_bug.cgi?id=164#c180">comment #180</a> _correctly_ describes and summarizes what is really wanted.

It's not focusing on how it will be implemented (using ICU or not, how to integrate it in PHP if it's used, otherwise how to represent the DUCET and how to represent the language tailorings...), and it explains why the development can be planned in several clearly independant steps that can be tested separately.

It correctly explains the dependancies and why any change in the SQL schema can be and should be delayed. In fact I consider the step (1) in my plan to have a high priority on all the rest, and it does not imply any immediate change in the schema to support it.

There will be some time needed only to assert that the implemented collations are effectively correct for various languages: this will be verifiable by users looking at list of terms in some wiki page, using a &quot;sortable wikitable&quot; whose rows are using the new {{SORTKEY:text|locale|level}} parser function.

If this is validated by users, then only two independant development phases can be started (in parallel):

- to develop the new schema for stored sortkeys, based only on the internal PHP functions implementing {{SORTKEY:text|locale|level}}. The schema should NOT be deployed before the collations have been tested extensively by users and their internal data structures reflect the wanted collations order and tailorings.

- to develop the {{COLLATIONMAP:text|locale|level|clusters}} parser function (for later inclusion in the generation of the correct &quot;column headings&quot; in the lists displayed by category pages, because for now these headings are almost useless for anything else than English, or in heavily populated categories).

The second function will be separately integrable in the display of category pages (before or after the schema has been updated for stored sort keys), but can be tested separately as well. And anyway, it will already be a very useful general clear-text function for use in wiki templates that are trying to equate &quot;equivalent&quot; strings (for example in a {{#switch:}}, even better than {{LC:text}}) and will be very convenient for some languages like Arabic, Hebrew and Russian that have optional diacritics in their orthographies (such as cantillation marks, dots for vowels, and tonic accents) or that may contain compatibility ligatures or display forms (e.g. narrow/wide kanas and square clusters of kanas in Japanese, &quot;compatibility jamos&quot; in Korean).

The name of this second function could be abbreviated as {{CMAP:}} (it does not matter, but it should be implemented based on its functional description by Unicode in one of its UAX) or could be localized as well like other &quot;magic&quot; wiki keywords. And it probably should use {{CONTENTLANGUAGE}} as the default value for the second parameter &quot;locale&quot; (because {{int:lang}} may cause rendering problems in some pages that do not want to depend on the user's prefered language). And by default the &quot;level&quot; parameter will be 1 (could be up to 3, any higher value will return the same text without performing any mapping because higher collation values have to contain all the collation differences), and the default &quot;clusters&quot; will be unlimited.</pre>
    </div><div id="c189" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c189">Comment 189</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-25 17:22:32 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c186">comment #186</a>)
<span class="quote">&gt; That'a a bad assumption : even the highest quality collations will need to be
&gt; updated from time to time:
&gt; - Unicode evolves and new characters get encoded (new versions are published
&gt; about every 1-2 years after synchronization and final balloting at both ISO WG2
&gt; and the UTC.
&gt; - The content of the Unicode DUCET is NOT stable: characters are inserted in
&gt; the sequence so that the full list of collation weights needs to be offseted
&gt; where the new characters get inserted.
&gt; - Collations for languages get corrected. We should be able to upgrade these
&gt; rules when the CLDR project produces new tailorings (CLDR updates are published
&gt; separately, about every 1-2 years.)</span >

It's not critical for most wikis to use the very latest collations, though.  The English Wikipedia, for example, will do fine with even very out-of-date collations, since the article names overwhelmingly use characters that have been in Unicode for an extremely long time.  The same is true for most other large wikis; but on the other hand, to change collations on small wikis will be fast in any event.

However, Tim Starling independently suggested a cl_collation column, and my initial implementation does have one.  The current one doesn't allow the same row to be stored multiple times with different collations, so sorting might still be wrong as the collation is updated, but this might not be a big problem in practice.  If it is, we can go with your idea of extending the primary key to (cl_collation, cl_from, cl_to) instead of (cl_from, cl_to).

<span class="quote">&gt; Anyway you did not reply to the idea of first developin the parser functions
&gt; and test them. Developping the SQL schema extension should not be attempted
&gt; before at least the first function {{SORTKEY:text|locale|level}} has been fully
&gt; developed and tested on specific pages (it can be tested easily in tables).</span >
&gt;
<span class="quote">&gt; The second function {{COLLATIONMAP:text|locale|level|clusters}} is not needed
&gt; immediately to develop the schema, but will be useful to restore the
&gt; functionality of headings. Headings don't need to be stored as they can be
&gt; computed on the fly, directly by reading sequentially the sorted result set
&gt; from the SQL query:</span >

I tried to figure out what you were talking about here, and eventually figured out that you just want me to expose Language::convertToSortkey() and Language::firstLetterForLists() (as they're currently called) as parser functions, for the benefit of lists.  That might be useful, and should be easy to do, although it's not part of my assigned job here.

<span class="quote">&gt; You can compute headings from the returned page names, or from the existing
&gt; stored &quot;cl_sortkey&quot; which should be used now ONLY to store the plain-text
&gt; specified in articles with {{DEFAULTSORT:sortkey}} and
&gt; [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]].</span >

I've introduced cl_raw_sortkey to store that, while retaining cl_sortkey for actual sorting.  Based on your feedback, it might make more sense to rename cl_raw_sortkey to cl_sortkey_prefix, put {{defaultsort:}} into it, and make it the empty string by default.

(In reply to <a href="show_bug.cgi?id=164#c187">comment #187</a>)
<span class="quote">&gt; This does not require any change in the schema. This can be made immediately by
&gt; MediaWiki developers and will not influence the developement of all corrections
&gt; needed for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Support collation by a certain locale (sorting order of characters)"
   href="show_bug.cgi?id=164">bug #164</a> itself.</span >

Correct.  I'll probably do it anyway in the course of the work I'm doing, though, since I'll be rewriting CategoryPage.php's sort logic in any case.

<span class="quote">&gt; For example in people's names whose page name is &quot;FirstNames LastName&quot; but that
&gt; we want to sort as if they were &quot;LastName, FirstNames&quot; by indicating only
&gt; {{DEFAULTSORT:LastName !}} (it should not needed to include the FirstNames in
&gt; the wiki text, as this sort hint will not be unique and the group of pages
&gt; using the same hint will still need to sort within this group using their
&gt; natural order).</span >

I can append the page title to cl_raw_sortkey before computing cl_sortkey.  That shouldn't be a problem.  As noted above, maybe renaming it to cl_sortkey_prefix would make more sense.

(In reply to <a href="show_bug.cgi?id=164#c188">comment #188</a>)
<span class="quote">&gt; An &quot;interface&quot; function is DEFINITELY NOT an &quot;implementation&quot; detail. My
&gt; <a href="show_bug.cgi?id=164#c180">comment #180</a> _correctly_ describes and summarizes what is really wanted.</span >

Unfortunately, it's hard for me to understand what you're saing.  However, I think I've got it now, at least mostly.  I don't think parser functions are essential, here, and they're not strictly part of this bug.  They can be added after the initial implementation is finished.

<span class="quote">&gt; It correctly explains the dependancies and why any change in the SQL schema can
&gt; be and should be delayed. In fact I consider the step (1) in my plan to have a
&gt; high priority on all the rest, and it does not imply any immediate change in
&gt; the schema to support it.</span >

Writing those functions is not part of my job.  I expect the i18n people will handle that.  I'm just doing a prototype, which is agnostic about what sortkey function you give it.  My current sortkey function is just strtoupper(), for testing.  (This does improve English sorting when $wgCapitalLinks is off.)

<span class="quote">&gt; - to develop the new schema for stored sortkeys, based only on the internal PHP
&gt; functions implementing {{SORTKEY:text|locale|level}}. The schema should NOT be
&gt; deployed before the collations have been tested extensively by users and their
&gt; internal data structures reflect the wanted collations order and tailorings.</span >

This is basically what I'm doing, except I'm not going to work out exactly what sortkey function to use.

<span class="quote">&gt; - to develop the {{COLLATIONMAP:text|locale|level|clusters}} parser function
&gt; (for later inclusion in the generation of the correct &quot;column headings&quot; in the
&gt; lists displayed by category pages, because for now these headings are almost
&gt; useless for anything else than English, or in heavily populated categories).</span >

I'm not doing this part, but I'm setting up the framework so that i18n people can work on it (minus the parser function, which can be added later).  At least, if your COLLATIONMAP is meant to be anything like my Language::firstLetterForLists().  I'm not sure if it is.  If it's not, please explain better, because I don't follow.</pre>
    </div><div id="c190" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c190">Comment 190</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 18:38:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Yes Language::firstLetterforList(s) maps more or less to COLLATIONMAP, but COLLATIONMAP is a more generic concept which reflects what is defined in Unicode standard annexes, which speaks about various mappings (including collan mapppings, but also case mappings)

One bad thing about the name Language::firstLetterforList(s) is that it implies that this should only be the first letter. In fact, for many locales, the significant unit is not the letter, but the collation element (for exemple digrams like &quot;ch&quot; or trigrams like &quot;c’h&quot;).

For some categories, it should be convenient also to be able to use longer substrings, containing more than one grapheme cluster (in Wiktionnary for lists of terms belonging to a language, or in lists of people names, a category may need to be indexed and anchored with section headings containing the first 2 or 3 grapheme clusters, because the first grapheme is not discriminant enough and will remain identical an all columns of the disaplyed list on one page, and even sometimes on several or many successive pages : the first letter heading does not help, and is just an unneeded visual pollution)

For other categories that have very few contents, too many headings are frequently added that also appear as pollution. Being able to suppress all of them, by specifying 0 graphemeclusters in that category will better help readers locate the wanted item.

The collation map also has several levels of implementations, which match exactly the same levels as collation levels used to generate sort keys.

----

About sort keys now:

As sort keys are intended to be opaque binary objects, they do not qualify as being used directly as a parserfunction, without being exposed by a serialization to safe Unicode text, even if it means nothing for reader. That's why I proposed a Base-36 mapping to plain ASCII which will still sort correctly in binary order, and for use in sortable tables, but it could use any arbitrary Base that sorts correctly using binary ordering, and that uses ONLY valid Unicode characters.

The chosen base should be easy to compute, but all the standard Base-64 variants do not qualify (there's no warranty for the last two &quot;letters&quot; of all base-64 variants). We could use Base-62 (using all 10 digits, and the 26 pairs of Basic Latin letters), or Base-32 (simpler to compute but will generate longer texts). The only intent is not really to make the string visible in pages, but to help in the generation of accurate sort keys in sortable columns.

For now these sort keys are generated by templates as invisible text spans (using a CSS style=&quot;display:none&quot; attribute), but ideally, the templates used in sortable tables that generate custome sortkeys should put them in some HTML attribute that can be specified on table cells, and that the Javascript will use directly. In my opinin, these opaque strings should be as compact as possible, but still safe for use inclusing in pages, and directly usable by simple Javascript without requiring any complex reimplemementation of UCA in the Javascript code.


Why do I think that exposing the functions as parser functions will be useful ? that's because it allows the implementation to be tested extensively on lots of cases, but only within a limited set of pages, long before the schema is developed, finalized and finally deployed.

In other words, it will not block the development of the schema update, as long as we agree about what are the essential functions to support, i.e. their interface that will be exposed (partly) in parser functions.

Also because I'm convinced that the exposed parser functions will not have this syntax changed, and that what they return will be well known:

- The {{COLLATIONMAP:}} function is very well described and will effectively return humane-readable text. Its formal implementation should follow the standard Unicode definitions.

You can expose it at least in a test wiki where you'll be able to track very easily the result and progress of its implementation (just create a page containing test words in various languages, arranged in a Wikitable).

- The {{SORTKEY:}} function can be exposed as well (and tested on the same test page for various languages, using the same list of words). Its result will be opaque for humane and compact. It will be easy to assert that it generates the expected sort order by using it in a sortable wikitable.


Both functions will be deployable rapidly, even on wikis that won't want to apply the schema change (so they will continue to use a single collation order for ALL their categories, and will anyway be able to sort specific categories using another supplied locale matching the category name).

If you think about it, changing the SQL schema may be rejected at end by lots of people. Exposing the parser functions will provide a convenient alternative that can be deployed much more simply, and with MUCH LESS risks, using the existing facilities offered by [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]] and {{DEFAULTSORT:sortkey}}, except that their parameter will be computed using the exposed {{SORTKEY:}} function:

  {{DEFAULTSORT:{{SORTKEY:text|locale|level}}}}

or:

  [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|{{SORTKEY:text|locale|level}}]]

both being generalizable through helper templates.


There is such existing helper template named [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Mod%C3%A8le%3ACl%C3%A9%20de%20tri">Modèle:Clé de tri</a>]] in French Wiktionnary, that will NO LONGER need that we pass the article name without accents or extra punctuations or apostrophes (ignored at collation level 1), this parameter becoming ignored. Currently we use the template like this:

  {{clé de tri}}

when the article name contains nothing else than basic Latin letters or spaces, otherwise we have to pass:

  {{clé de tri|Basic latin}}

And we contantly need to verify that the passed parameter is correct. Instead the template would just generate this very simple code:

  {{DEFAULTSORT:{{SORTKEY:{{PAGENAME}}}}}}

As the {{SORTKEY:text|locale|level}} will use by default:

  locale={{CONTENTLANGUAGE}}|level=1

this will be sufficient for French Wiktionnary. In fact it may also be sufficient in English Wikipedia.


But in Chinese Wikipedia, one may still want to be able to use:

  {{DEFAULTSORT:{{SORTKEY:{{PAGENAME}}|{{int:lang}}}}}}

to support the prefered collation order of the user (traditional radical/stroke order, simplified radical/stroke order,  Bopomofo order, Pinyin order)

(Note also that section headings (&quot;first letter&quot;) will have to be &quot;translated&quot; to correctly report the &quot;first letter&quot; of the Pinyin romanization, because the page names listed will continue to display their distinctive ideographs ! The only way to do that is to use the collation mapping exposed by {{COLLATIONMAP:}})

But you'll note that it won't be possible to sort the categories using multiple locales, so the page will be stored and indexed by parsing it using {{int:lang}} forced to {{CONTENTLANGUAGE}}, which will just be &quot;zh&quot;, using only the simplified radical/stroke order by default.

To support more collations, the categories will need to support them explicitly (but this would force to reparse the page multiple times, once for each additinal locale specified in the category).

The alternative would be to create multiple parallel categories, one for each sort order, but then each article will have to specify all these categories.

My opinion is that the same category should be sortable using different locales, and that's why they should support multiple sortkeys par indexed page, one for each specified locale. Some wikis will only sort on the {{CONTENTLANGUAGE}} by default, but the Chinese Wiktionnary will benefit of sorting automatically all categories using at least the default &quot;zh&quot; locale which is an alias for &quot;zh-hans&quot;, plus the &quot;zh-hant&quot; locale for traditional radical/stroke order, &quot;zh-latn&quot;  for the Pinyin order, and &quot;zh-bpmf&quot; for the Bopomofo order.

The exact locale to which &quot;zh&quot; corresponds will be a user preference, but one will be able to navigate by clicking the automatically generated links that will allow them to specify the other collation orders supported specifically by the category or by default throughout the wiki project.

For example, the Chinese Wiktionnary will display links on the page showing the available choice as:

 Sort by : [default] | [simplified radical/stroke] | [traditional radical/stroke] | [pinyin] | [bopomofo]

How can this be possible ? Either the wikiproject specifies that all categories will support these 4 orders, or the category page will list explicitly the additional sort orders that will be supported by the category.

The [default] link will use the index prefixes specified in the existing syntaxes [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkeyprefix]] or {{DEFAULTSORT:sortkeyprefix}}

All the other links will display the list sorted using the additional locales specified, but will ignore the sortkeyprefixes specified in categorized pages or indirectely via templates.

To add the additional sort orders in a category, you'll just need to insert in the category page some code like:

{{SORTAS:zh-hans}}
{{SORTAS:zh-hant}}
{{SORTAS:zh-latn}}
{{SORTAS:zh-bpmf}}

No article needs to be changed, these additional sort orders will just discard/ignore the sortkeyprefix when generating the actual opaque sortkey (specified with {{DEFAULTSORT:sortkeyprefix}} or in [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkeyprefix]].

However if the wikiproject offers several project-wide default locales the sortkeyprefix specified in pages will be honored for ONLY for these locales, and made immediately visible as the preselected [default] link, in the choice of sort orders.



Lets say for example that the Chinese Wiktionnary wants to support by default only the &quot;zh-hans&quot; and &quot;zh-hant&quot; collations.

This means that all categories will contain [default] sort keys computed for these two collations, from the text consisting in:

  {{{sortkeyprefix}}}{{KEYSEPARATOR}}{{PAGENAME}}

if a sortkeyprefix is specified, or just {{PAGENAME}} if no sortkeyprefix is specified.

A constant {{KEYSEPARATOR}} will be used that should sort lower than every other valid text usable in {{{sortkeyprefix}}} or {{PAGENAME}}. Ideally, this should be a control character like U+000A (LF) or U+0009 (TAB), after making sure that:

- this character will never appear in valid {{{sortkeyprefix}}} or {{PAGENAME}} (Mediawiki already process blanks and convert them to plain SPACE)

- this character will have a NON-ZERO (ignorable) primary collation weight that is smaller than all other collation weights. Its primary collation weight should then be 1 (if needed the collation weights coming from the DUCET or from loalized tailoring will just have to be offseted by 1, if they are non-zero)

- this character will have a ZERO collation weight for all the remaining supported levels in each locale

For all the additional sort orders specified in category pages, the {{{sortkeyprefix}} will be ignored as well as the {{KEYSEPARATOR}}, so the pages will just be indexed on {{PAGENAME}}, within the specified locale.

In the example Chinese Wiktionnary a category specifying:

{{SORTAS:zh-hans}}
{{SORTAS:zh-hant}}
{{SORTAS:zh-latn}}
{{SORTAS:zh-bpmf}}

will generate 4 additional (non [default]) sort keys, that will add to the two sortkeys already generated for &quot;zh-hans&quot; and &quot;zh-hant&quot; except that they will ignore the specified sortkeyprefixes.

This means that it will generate up to 6 sortkeys: 1 or 2 for &quot;zh-hans&quot;, 1 or 2 for &quot;zh-hant&quot;, and only 1 for each of &quot;zh-latn&quot; and &quot;zh-bmpf&quot;

In the English Wiktionary or on Commons, that will only use the &quot;en&quot; default collation order (identical to {{CONTENTLANGUAGE}}), it will be possible to specify, for specific categories, an additional sort order when the category is directly related to a specific language.

By default, that category will be sorted using the English collation rule, but it will be possible to select the additional specified collation order (in which case the defaultsortprefix specified in indexed pages will be ignored, the list will just be shown by using the natural order of page names in the manually clicked sort order).

So the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3AChinese">Category:Chinese</a>]] in English Wiktionnary will be able to specify at least:

{{SORTAS:zh-hans}}

And the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3AGerman">Category:German</a>]] in English Wiktionnary will be able to specify at least:

{{SORTAS:de|2}}

And the [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3AFrench">Category:French</a>]] in English Wiktionnary will be able to specify at least:

{{SORTAS:fr|2}}

And this should be enough to be able to view the natural order of these languages (French will require collation level 2 for correct ordering by grouping letters with the same accents, and sorting them in backward order in this level)...

Note also that if the categories is presented in any selected locale, the secntion headings will also be computed in that same locale, and with the same collation level. By default it will show only 1 grapheme cluster. But if needed you can specify:

{{SORTAS:fr|2|3}}

to indicate that the category should use the first three French grapheme clusters (determined from collation mappings) for the headings, if the category is heavily populated, so you'll get the following headings:

a, à, â, ... aa, aar, ab, aba, abc, ac, aca, ace, acé, ... ad, ae, aé, ... b, ba, bac, bad, baf, bag, bai, bal, bam, ban, bar, bas, bat, bât, ....

(note that at level 2, the same heading will contain all words sharing the same letters and accents. Case will be ignored.

Headings don't need to be stored, they are generated on the fly from the index prefixes (returned in the result set, but only if this is one of the wiki's [default] sort orders, because otherwise it will be empty if the user selected a non-[default] sort order) and the pagename (also present in the result set).

Note that if you still want to present a category ordered so that all lowercase letters will sort tegether separately from all other uppercase letters, you'll need to indicate a separate collation order, by specifying an additional non-default locale in that specific category. This will look probalby not natural for most users, that's why it will be a distinct locale and not the default. For example to use it in English or in French:

{{SORTAS:en-x-uc}}&lt;!-- ALL uppercase before lowercase in collation level 1--&gt;
{{SORTAS:fr-x-lc}}&lt;!-- ALL lowercase before uppercase in collation level 1 --&gt;

This variant means that the natural tailoring is modified so that case differences will be considered as primary differences in that specific distinct localized collation. There will no longer be any ternary difference but there will be twice more headings generated (here as no maximum grapheme clusters is specified, only 1 grapheme cluster will be used in the headings, so you'll get the headings:

 A, B, C, D, ... Z, a, b, c, d, ... z, (in with en-x-uc)
 a, b, c, d, ... z, A, B, C, D, ... Z, (in with fr-x-uc)

And in both cases there will be no headings separating differences of accents (because we did not indeicate the collation level, the collation level remains 1)

Such options MUST use a standard BCP47 code, so the option needs to be at least 5 characters long after the language code, or must be used after the standard BCP47 suffix &quot;-x-&quot; for private extensions that are not indicating a language.</pre>
    </div><div id="c191" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c191">Comment 191</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 19:07:34 UTC
        </span>
      </div>



<pre class="bz_comment_text" >In all this discussion it appears that the development can be made in two separate projects developped independantly.

You can continue to develop the SQL schema extension, provided that:

- you call a PHP function/method that will be developped separately in a &quot;Collator&quot; class, to compute the collation sortkeys for each locale and specified collation level.

- you call a PHP function/method that will be developped separately in a &quot;Collator&quot; class, to compute the collation mappings for each locale and specified collation level and maximum grapheme clusters, in order to generate the headings on the fly in the category list

- you think about a HTTP query parameter that will allow to change the locale (this parameter exists, it's &quot;uselang&quot;, but another one will be needed eventually to specify sort options like &quot;-x-lc&quot; or &quot;-x-uc&quot; (the &quot;-x-&quot; separator will be used impliclty. So the HTTP query may contain: &amp;uselang=fr&amp;opt=lc). These parameters will be used later when you'll be able to store multiple sortkeys.


Separately, another project will implement the Collator class, that will load the DUCET table, load the tailorings designed per locale or locale+&quot;-x-&quot;+option, and prepare the table of collation elements and their associated collation weights for each level. Then it will implement the methods:

- Collator::Collator(locale, level=1) which instanciates a Collator object for the specified locale string (language + optional options) and the collation level (it does not need to prepare the full table of colaltion weights, just those needed for the specified level). The default level will be 1.

- Collator::sortkey(text) which returns the opaque collation key (a binary array of bytes) for the specified Collator instance.

- Collator::map(text, maxelements='') which returns the humane readable text after applying the collation mapping associated to the Collator instance. It will stop after returning at most 'maxelements' collation elements in the remapped string, or will process all the text if maxelements is null or not specified. For category headings, you'll give by default maxelements=1 (unless another calue was specified when preparing a specific locale with the extra option of {{SORTAS:locale|maxelements}} in the visited category page.


Separately another simple project will use the Collator class to expose them in parser functions. In fact this third project will be very easy and fast to complete, even if the Collator class is not fully developped with all its options.

A very basic Collator class can be used to develop the parser function extension that will expose:
-  {{SORTKEY:text|locale|level}}
   defaults: locale={{CONTENTLANGUAGE}}|level=1
- {{COLLATIONMAP:text|locale|level|maxelements}}
   defaults: locale={{CONTENTLANGUAGE}}|level=1|maxelements=&lt;!--empty/null--&gt;

With it you can immediately deply it on a test wiki server, where you'll build test lists in a &quot;sortable wikitable&quot;. and you can continue building the Collator class. to support various locales and all the needed options.</pre>
    </div><div id="c192" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c192">Comment 192</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 19:20:35 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that this is the minimum functional interface for the Collator class. Other methods will be certianly needed to cache the already prepared collators, or to cache the preloaded tailoring tables and the common DUCET.

In other words, the Collator::Collator() constructor is in fact probably using the service of a CollatorFactory class that will cache the needed shared data. This will save a lot of overhead and will be important for the performance.

This factory should NOT be used directly by the SQL schema extension, that MUST only use the Collator::getCollator(locale, level) static function which will use the CollatorFactory in order to instantiate the Collator object through its constuctor.

The CollatorFactory will use ICU, most probably, via its already existing PHP-extension interface module. But a basic PHP-only implementation is still possible without using ICU immediately, or if MediaWiki must be kept compatible with existing PHP servers that can't load such native extensions (using DLLs or shared libraries or requiring to recompile/relink PHP itself) in their installation.

The CollatorFactory should NOT prepare all supported locales. Only those that are requested **on demand**.</pre>
    </div><div id="c193" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c193">Comment 193</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 19:41:57 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Exemple of interface for you:

&lt;?php

require('.../CollatorFactory.php');
$wgCollatorFactory=CollatorFactory(); // this is the only global PHP variable

...

// prepare a Collator object
//(note that $locale is NOT case sensitive in BCP47)

$locale = $wgContentLanguage; // use {{CONTENTLANGUAGE}} by default
if (isset($options) &amp;&amp; $options &gt; '')
  $locale .= '-x-' . $options; // append sort options if any (like 'uc', 'lc')
$level = 1; //use collation level 1 by default

$collator = $wgCollatorFactory-&gt;get($locale, $level);

...

// use the collator object to compute opaque sortkeys (opaque binary string)
// to store in categories:

$sortkey = $collator-&gt;sortKey($text);

// optionally map it to plain-text, if the database can't store and
// sort VARBINARY(N) fields, but only VARCHAR(N) objects:

$sortkey = base32($sortkey);

...

// use the collator object to compute a heading on the fly from a pagename:

$collationElements = 1; // by default generate only 1 collation element

$heading = $collator-&gt;map($pageName, $collationElements);</pre>
    </div><div id="c194" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c194">Comment 194</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 19:49:15 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c190">comment #190</a>)
<span class="quote">&gt; Yes Language::firstLetterforList(s) maps more or less to COLLATIONMAP, but
&gt; COLLATIONMAP is a more generic concept which reflects what is defined in
&gt; Unicode standard annexes, which speaks about various mappings (including collan
&gt; mapppings, but also case mappings)</span >

Which particular Unicode standards are relevant here?  It would probably be a good idea for me to take a look at them.

<span class="quote">&gt; For some categories, it should be convenient also to be able to use longer
&gt; substrings, containing more than one grapheme cluster (in Wiktionnary for lists
&gt; of terms belonging to a language, or in lists of people names, a category may
&gt; need to be indexed and anchored with section headings containing the first 2 or
&gt; 3 grapheme clusters, because the first grapheme is not discriminant enough and
&gt; will remain identical an all columns of the disaplyed list on one page, and
&gt; even sometimes on several or many successive pages : the first letter heading
&gt; does not help, and is just an unneeded visual pollution)
&gt; 
&gt; For other categories that have very few contents, too many headings are
&gt; frequently added that also appear as pollution. Being able to suppress all of
&gt; them, by specifying 0 graphemeclusters in that category will better help
&gt; readers locate the wanted item.</span >

This is all beyond the scope of what I'm currently doing, but it should be possible to add on without too much trouble as a separate project.

<span class="quote">&gt; Why do I think that exposing the functions as parser functions will be useful ?
&gt; that's because it allows the implementation to be tested extensively on lots of
&gt; cases, but only within a limited set of pages, long before the schema is
&gt; developed, finalized and finally deployed.</span >

This presupposes that the sortkey generation algorithm is settled upon before the database changes are.  In fact, it's exactly the opposite: I've been contracted to do the backend changes, and other people will figure out how exactly to generate the sortkeys later.  Really, we could do the changes in either order.

<span class="quote">&gt; Both functions will be deployable rapidly, even on wikis that won't want to
&gt; apply the schema change (so they will continue to use a single collation order
&gt; for ALL their categories, and will anyway be able to sort specific categories
&gt; using another supplied locale matching the category name).
&gt; 
&gt; If you think about it, changing the SQL schema may be rejected at end by lots
&gt; of people.</span >

The schema change will be part of the core software and will not be an optional update.  Anyone who doesn't want to accept it will likely have to stick with 1.16 forever, because we're not going to support the old schema.

<span class="quote">&gt; Exposing the parser functions will provide a convenient alternative
&gt; that can be deployed much more simply, and with MUCH LESS risks, using the
&gt; existing facilities offered by [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]] and
&gt; {{DEFAULTSORT:sortkey}}, except that their parameter will be computed using the
&gt; exposed {{SORTKEY:}} function:
&gt; 
&gt;   {{DEFAULTSORT:{{SORTKEY:text|locale|level}}}}
&gt; 
&gt; or:
&gt; 
&gt;   [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|{{SORTKEY:text|locale|level}}]]
&gt; 
&gt; both being generalizable through helper templates.</span >

It's not particularly less risky.  It does encourage each wiki to hack around the problem locally instead of pushing for a proper fix in the software.  You shouldn't have to do DEFAULTSORT on any pages where the right sorting is human-detectable -- it should only have to be for things like &quot;Abraham Lincoln&quot; being sorted as &quot;Lincoln, Abraham&quot;, which the software can't do automatically.

<span class="quote">&gt; (Note also that section headings (&quot;first letter&quot;) will have to be &quot;translated&quot;
&gt; to correctly report the &quot;first letter&quot; of the Pinyin romanization, because the
&gt; page names listed will continue to display their distinctive ideographs ! The
&gt; only way to do that is to use the collation mapping exposed by
&gt; {{COLLATIONMAP:}})</span >

Surely the most sensible idea is just to disable the section headings altogether for CJK?

<span class="quote">&gt; My opinion is that the same category should be sortable using different
&gt; locales, and that's why they should support multiple sortkeys par indexed page,
&gt; one for each specified locale. Some wikis will only sort on the
&gt; {{CONTENTLANGUAGE}} by default, but the Chinese Wiktionnary will benefit of
&gt; sorting automatically all categories using at least the default &quot;zh&quot; locale
&gt; which is an alias for &quot;zh-hans&quot;, plus the &quot;zh-hant&quot; locale for traditional
&gt; radical/stroke order, &quot;zh-latn&quot;  for the Pinyin order, and &quot;zh-bpmf&quot; for the
&gt; Bopomofo order.
&gt; 
&gt; The exact locale to which &quot;zh&quot; corresponds will be a user preference, but one
&gt; will be able to navigate by clicking the automatically generated links that
&gt; will allow them to specify the other collation orders supported specifically by
&gt; the category or by default throughout the wiki project.</span >

This is doable if it's desired, as long as the number of locales is very limited (like four, not a hundred).  However, it will not be part of my initial implementation unless Tim asks me to do it.

<span class="quote">&gt; In the English Wiktionary or on Commons, that will only use the &quot;en&quot; default
&gt; collation order (identical to {{CONTENTLANGUAGE}}), it will be possible to
&gt; specify, for specific categories, an additional sort order when the category is
&gt; directly related to a specific language.</span >

This is certainly a useful feature for some wikis (especially Wiktionaries), and it could be added fairly easily.  It might make it into my initial implementation.

(In reply to <a href="show_bug.cgi?id=164#c191">comment #191</a>)
<span class="quote">&gt; In all this discussion it appears that the development can be made in two
&gt; separate projects developped independantly.
&gt; 
&gt; You can continue to develop the SQL schema extension, provided that:
&gt; 
&gt; - you call a PHP function/method that will be developped separately in a
&gt; &quot;Collator&quot; class, to compute the collation sortkeys for each locale and
&gt; specified collation level.
&gt; 
&gt; - you call a PHP function/method that will be developped separately in a
&gt; &quot;Collator&quot; class, to compute the collation mappings for each locale and
&gt; specified collation level and maximum grapheme clusters, in order to generate
&gt; the headings on the fly in the category list</span >

This is what I'm doing.

<span class="quote">&gt; - you think about a HTTP query parameter that will allow to change the locale
&gt; (this parameter exists, it's &quot;uselang&quot;, but another one will be needed
&gt; eventually to specify sort options like &quot;-x-lc&quot; or &quot;-x-uc&quot; (the &quot;-x-&quot; separator
&gt; will be used impliclty. So the HTTP query may contain: &amp;uselang=fr&amp;opt=lc).
&gt; These parameters will be used later when you'll be able to store multiple
&gt; sortkeys.</span >

These don't need to be developed until that feature is actually implemented, which will probably not be in my initial implementation, unless Tim Starling asks me to.</pre>
    </div><div id="c195" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c195">Comment 195</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 19:50:19 UTC
        </span>
      </div>



<pre class="bz_comment_text" >By the way, I'm keeping track of progress here:

<a href="http://www.mediawiki.org/wiki/User:Simetrical/Collation">http://www.mediawiki.org/wiki/User:Simetrical/Collation</a></pre>
    </div><div id="c196" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c196">Comment 196</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 20:37:46 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that the CollatorFactory may fail to locate the specified locale for which a collator is being requested. Additionally, several locales may share exactly the same collator.

In all cases, the collatorFactory will return a valid Collator object, whose locale can be identified: the Collator object returned by:

$collator = $wgCollatorFactory-&gt;get($locale, $level);

will have a property that will contain the effective locale code (normalized) and an other property containing the collation level from which it was effectively built. You should be able to access it simply with something like:

$effectiveLocale = $collator-&gt;locale();
$effectiveLevel = $collator-&gt;level();

after just getting the collator instance from the factory.

This may be useful to avoid storing duplicate equivalent binary sortkeys, or simply to determine which effective locale to use in SQL select queries (to retrieve the sorted list of pagenames ordered by a specified locale), when the SQL schema will be able to store several sortkeys for the same page in the same category.

The factory will also instanciate a collator with an effective locale and an effective collation level only once, caching it in an internal array, for repeated use.

This will save the complex preparation of tables, and will avoid building tables for all supported languages (for example in Commons where lots of languages may be desirable, weahc one with possibly several sort options, or supported conversions to other scripts or script variants).

The factory however should probably be able to load the DUCET table associated to the CLDR &quot;root&quot; locale completely and immediately when it is first instanciated and stored in the global variable (there's probably no need to test this each time vecaue of lazy initializations with null member fields); and it should most probably build the default collator (for $locale=$wgContentLanguage, and $collationlevel=1) immediately, storing it in the first position of its member array of already prepared Collator instances.

But you may think the opposite, in order to speedup the server startup by some (milli-)seconds or reduce the initial CPU/memory stress in the garbage collator of PHP. However I'm not convince that the server will be ready faster, and the extra tests that will be performed at each use of the $wgCollatorFactory-&gt;get() method may impact the performance at runtime...

Note also the ICU uses the same approach of a CollatorFactory to build and cache reusable Collator instances, because it's a proven good design pattern for implementing and using collators.

A collator object may also be used to compare to texts without even generating their sortkeys, or without mapping them, so it may help to include in the Collator interface this method:

$collator-&gt;compare($text1, $text2);

that will return an integer (in other words, a Collator also implements the Comparator interface), by parsing $text1 and $text2 collation element by collation element up to the end at level 1, comparing their collation weights only at theis level, before restarting with the next level. When the collator was instanciated at level 1, the successive collation elements need not be stored, but for higher levels, it helps if they are parsed only once and kept in an indexed array that will allow faster lookup for the next levels in the table of collation weights for these levels.</pre>
    </div><div id="c197" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c197">Comment 197</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 21:01:11 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I note that you have started to define the Collator class as the Language class.

Well I'm not sure that this should be the same class: a language has several collators, even if a collator is for only one language (including a virtual language like &quot;root&quot; which is the base of all localizations including English, with lots of common properties that are shared in multiple languages derived from root).

Also I note that the collator you define is a stub. Great for your development in the SQL schema, but someone else must work in implementing the CollatorFactory, using ICU, or a full PHP implementation, or only a stub, depending on the PHP script path you'll require() to load this factory class.

Technically, collators also share lots of properties across several languages. This is why it should be separated from the Language class.

May be the Language class can query the CollatorFactory about the list of collators (i.e. their complete locale code, including options) that are supported by that language, using an interface method of the loaded global CollatorFactory instance.

This way, a stub factory, building a single Collator instance will still work immediately.

Someone with expertise in Unicode collations will help you build the Factory if you want a PHP-only implementation.

Someone else with ICU expertize could also work on its existing integration in PHP (needs testing in the MediaWiki installation scripts for deployments) and to use it in the CollatorFactory and in the Collator class.

The most tricky development is the Collator::map() function, because Unicode does not describe the algorithm completely.

I know the principles and could offer help if you give some pointers where it would be beneficial.

But really, to test a complete implementation of the CollatorFactory, you'll need to be able to expose it in the two optional builtin parser functions that I described. As this can be clearly developped separately even if you start with a stub for the factory, and tested with the very basic Parser Functions installed on a test server.

So I maintain my position for the non-risky ParserFunctions (notably also because it will be simpler for an existing non-Wikimedia installation of MediaWiki to install the simple functions only, without upgrading to the new schema immediately, knowing that the factory can also be a basic stub as well on these installations).</pre>
    </div><div id="c198" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c198">Comment 198</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 21:43:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c187">comment #187</a>)
<span class="quote">&gt; Drop this tacking immediately in the PHP code: the cl_sortkey is only intended
&gt; to store the clear-text sortkey &quot;hint&quot; specified in {{DEFAULTSORT:sortkey}} or
&gt; [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>|sortkey]] to override the sort order, and this clear-text
&gt; sortkey is not really a true sortkey but a sort hint to override the default
&gt; sort order. 
&gt; 
&gt; For example in people's names whose page name is &quot;FirstNames LastName&quot; but that
&gt; we want to sort as if they were &quot;LastName, FirstNames&quot; by indicating only
&gt; {{DEFAULTSORT:LastName !}} (it should not needed to include the FirstNames in
&gt; the wiki text, as this sort hint will not be unique and the group of pages
&gt; using the same hint will still need to sort within this group using their
&gt; natural order). Even in that case, there's no need to bogously tack the cl_from
&gt; field in the stored field.</span >

How do you propose this be implemented?  We would need some character that sorts before all characters that can legitimately occur in a sort key.

(In reply to <a href="show_bug.cgi?id=164#c197">comment #197</a>)
<span class="quote">&gt; I note that you have started to define the Collator class as the Language
&gt; class.</span >

This is completely provisional and can easily be changed later.  As far as I understand, I'm not the one who will work on it.

<span class="quote">&gt; But really, to test a complete implementation of the CollatorFactory, you'll
&gt; need to be able to expose it in the two optional builtin parser functions that
&gt; I described. As this can be clearly developped separately even if you start
&gt; with a stub for the factory, and tested with the very basic Parser Functions
&gt; installed on a test server.
&gt; 
&gt; So I maintain my position for the non-risky ParserFunctions (notably also
&gt; because it will be simpler for an existing non-Wikimedia installation of
&gt; MediaWiki to install the simple functions only, without upgrading to the new
&gt; schema immediately, knowing that the factory can also be a basic stub as well
&gt; on these installations).</span >

Upgrading the schema will be handled by running maintenance/update.php, which must be run on every update anyway.  We typically have a number of schema changes in every release, and those always must be applied when deploying the new code.  So this is not an issue.</pre>
    </div><div id="c199" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c199">Comment 199</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 22:23:47 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt;&gt; (Note also that section headings (&quot;first letter&quot;) will have to be &quot;translated&quot;
&gt;&gt; to correctly report the &quot;first letter&quot; of the Pinyin romanization, because the
&gt;&gt; page names listed will continue to display their distinctive ideographs ! The
&gt;&gt; only way to do that is to use the collation mapping exposed by
&gt;&gt; {{COLLATIONMAP:}})</span >
&gt;
<span class="quote">&gt;Surely the most sensible idea is just to disable the section headings
&gt;altogether for CJK?</span >

Don't need to do that.

The Collator instance returned by the factory for $locale=&quot;zh-latn&quot; (which sorts using Pinyin) just has to return an empty string for its map() method, as long as this is a stub which can't safely map ideographs to Latin initial consonnants of the Pinyin syllable.

Note that the syntax of the Latin Pinyin ampping should be quite similar to the syntax used in Minnan as the Minnan syllables have more or less the same structure as the Pinyin syllables. for ideographs that are not supported, in the Pinyin romanization, there will be no substitution so they will sort at end and will not start by a Latin letter.

Here also, it is possible to infer a common heading for all of them, such as their radical component, or just the first ideographic radical encoded in the DUCET with a non zero primary weight, or even the first stroke.

The first CJK stroke is:
31C0  ; [*10E0.0020.0002.31C0] # CJK STROKE T

But I should look at the exact sequence in the &quot;zh&quot; tailoring of the DUCET, in the CLDR database.

There's a demo page for &quot;zh-hans&quot; collation here (in the ICU project which is used by the Unicode's CLDR project as a reference implementation):

<a href="http://demo.icu-project.org/icu-bin/locexp?d_=fr&amp;_=zh_Hans">http://demo.icu-project.org/icu-bin/locexp?d_=fr&amp;_=zh_Hans</a>

The interesting part is the data for &quot;Rules&quot; which orders the examplar sinograms, where the data for &quot;Set&quot; just show them in the numeric codepoint order or as ranges of character with ascending numeric code point values.
But on both cases they just concentrate on the most common basic subset used in GB2312, this is not the complete set defined in GB18030 and Unicode.

For actual transforms from Sinograms to Latin (Pinyin) there's this demo page:

<a href="http://demo.icu-project.org/icu-bin/translit">http://demo.icu-project.org/icu-bin/translit</a>

To see how the DUCET orders ideographs, look at:

<a href="http://unicode.org/charts/collation/">http://unicode.org/charts/collation/</a>

The first sinogram (non-stroke) defined with a non-zero primary weight in the DUCET sequence is U+4E00 (一) at it seems that it provides a very convenient geading for every sinogram that we can't sort or convert to Pinyin.

Note that in all cases all the sinograms are at end of the DUCET, just before the unsupported/reserved/unassaigned characters.

The &quot;zh-hans&quot; is just moving all the other letters starting in the &quot;Variable&quot; subset upward (in fact it just moves upwards the letters starting at Latin), to fit the sinograms before them.

The &quot;zh-Hant&quot; collation is like &quot;zh-Hans&quot; but swaps some positions, according to their expected radical, but also because they differ in thei stroke count.

Only about 31000 sinograms have known transiptions to Pinyin (this number is progressing), all the other will then appear under the remaining heading group starting by U+4E00 (一), except those in the &quot;CJK-Extension blocks&quot; that should be listed under the heading U+3400 (㐀).

Most non-extension CJK have now a pinyin transcription, most CJK extensions don't (but they are also the rarest character used, so there should not be a lot of pages indexed there)...

<span class="quote">&gt;&gt; For example in people's names whose page name is &quot;FirstNames LastName&quot; but that
&gt;&gt; we want to sort as if they were &quot;LastName, FirstNames&quot; by indicating only
&gt;&gt; {{DEFAULTSORT:LastName !}} (it should not needed to include the FirstNames in
&gt;&gt; the wiki text, as this sort hint will not be unique and the group of pages
&gt;&gt; using the same hint will still need to sort within this group using their
&gt;&gt; natural order). Even in that case, there's no need to bogously tack the cl_from
&gt;&gt; field in the stored field.</span >
&gt;
<span class="quote">&gt; How do you propose this be implemented?  We would need some character that
&gt; sorts before all characters that can legitimately occur in a sort key.</span >

This is exactly what UCA defines as a &quot;tailoring&quot;. We have such a character available that we don't use in pagenames and in sortkey prefixes: Control characters.

Note that control characters are present in the DUCET, and they are NOT ALL ignorable. The first of them is TAB (U+0009) and it is the first character that we DON'T USE, and that has a primary weight in the DUCET and that is not ignorable or null.

All the characters have null weights are listed wihin the NULL group, which is immediately followed by ignorable characters.

TAB has a primary weight of 0201 in the DUCET (it comes far later, after all the ignorables)

The first ignorable character has a primary weight 0021, so the primary weight 0001 is free to serve as the separator.

All we have to do is then to tailor the primary weight of TAB to assign it the weight 0001 instead of 0000. In that case, the souce text to give to Collator:sortKey() just has to use the TAB character between the two fields.

If there's no sortkey prefix, don't generate the TAB, use directly the pagename:
&lt;? php

require('.../CollatorFactory.php'); // choose the script for the implementation
global $wgCollatorFactor = CollatorFactory();

...
$collator = $wgCollatorFactory-&gt;get($locale, $level);

...
if ($sortkeyprefix != '')
  $text = $sortkeyprefix + '\t' + $pagename;
else
  $text = $pagename;
$sortkey = $collator-&gt;sortkey($text);

//optional to convert VARBINARY(N) to VARCHAR(N) (depends on SQL backend)
$sortkey = varbinaryToVarchar($sortkey); // e.g. Base-32

// you may also need to truncate to N characters,
// to fit the SQL sortable field maximum length constraint
// (according to the schema for this SQL backend)...</pre>
    </div><div id="c200" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c200">Comment 200</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 22:44:37 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Note that if your collator stub does not really compute true sort keys (compacted in binary format and representing collation weights), it may return spaces (U+0020), that is represented by byte 0x20 in the UTF-8 encoding. The separator used must be lower than this encoded character, so the VARCHAR(N) database field has to accept this character.

If it does not, you may offset all the UTF-8 bytes returned by your stub by 1 (because UTF-8 bytes never use the byte value 0xFF), so that you'll be able to ue the byte value 0x20 for the separator (the UTF-8 encoded SPACE will be stored in the sortkey field as 0x21 after it has been offseted).

This does not matter because sortkeys are opaque, so this is stimple to do in the stub. The stored sort key field DOES NOT have to use the UTF-8 encoding explicitly, it must just accept binary encoded bytes that can fit a non-Unicode character. If the database wants you to specify a charset for this binary sortable field, use ISO-8859-1, as long as the database will not alter the binary order of ISO-8859-1 when computing ORDER BY clauses.

I really hope that we will always have the possibility of using VARBINARY(N) fields allowing compact random byte values, because it will be much more efficient for our use of opaque binary sortable sort keys (that are just streams of bytes).

Be also careful about the sign of bytes (i.e. their range value), otherwise byte 0x80.0xFF will sort before 0x00..0x7F in the order by clause. This should be the case if the field is declared to use the ISO 8859-1 encoding with its binary order.

Which SQL backends (and dialects) do you support in MediaWiki ? This may help me understanding some development constraints. I know you support MySQL, but are there simpler backends like BerkeleyDB, dBase files, or flat text files for small projects supported only via some ODBC driver with a PHP interface ?</pre>
    </div><div id="c201" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c201">Comment 201</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">V85</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-26 23:02:33 UTC
        </span>
      </div>



<pre class="bz_comment_text" >For those of us who are less technical, but keen to see this bug resolved, is there somewhere where we can submit alphabets, so that they may be added for collation? I.e. where we submit the sorting order of specific languages for use with {{sort:en}} (or whatever the mark-up will be)?</pre>
    </div><div id="c202" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c202">Comment 202</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-28 22:06:54 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I would suggest instead making those proposals in the CLDR project.
It already contains lots of data for many languages, related to their expected &quot;sort order&quot; (in fact more generally about their collation).

Go to <a href="http://www.unicode.org/cldr">http://www.unicode.org/cldr</a> and visit the existing ressources browser, and the demo of ICU which uses the same data.

Our collator should &quot;in fine&quot; use the CLDR tailorings that are already defined, with very minor changes (if they are really needed).</pre>
    </div><div id="c203" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c203">Comment 203</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-07-28 22:18:49 UTC
        </span>
      </div>



<pre class="bz_comment_text" >May I even suggest that the name of the new column does not even use &quot;sortkey&quot;

i.e. &quot;cl_sort_prefix&quot; instead of &quot;cl_sortkey_prefix&quot;

Why? because this column should NEVER need to convert that prefix itself to a binary sortkey, it should just still be the humane-readable prefix that was specified in {{DEFAULTSORT:sort_prefix}} or in [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3A...">Category:...</a>|sort_prefix]].

This will avoid confusion, but it will also allow simpler recomputing of actual sortkeys for various locales, without having to parse the page again for each locale:

Note that when evaluating and expanding the parameters of {{DEFAULTSORT:sort_prefix}} and of [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3A...">Category:...</a>|sort_prefix]] in the wiki code of a page (or when transcluding templates), the result text should NEVER depend on the UI language (so if {{int:lang}} is used in that parameter, it should evaluate always as if it was {{CONTENTLANGUAGE}}).</pre>
    </div><div id="c204" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c204">Comment 204</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-08-03 17:37:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c200">comment #200</a>)
<span class="quote">&gt; Which SQL backends (and dialects) do you support in MediaWiki ? This may help
&gt; me understanding some development constraints. I know you support MySQL, but
&gt; are there simpler backends like BerkeleyDB, dBase files, or flat text files for
&gt; small projects supported only via some ODBC driver with a PHP interface ?</span >

We primarily support MySQL.  We also have at least theoretical support for PostgreSQL, SQLite, MSSQL, Oracle, and DB2.  However, if this doesn't work for all DB backends, it's not a big deal, as long as it works with MySQL.

(In reply to <a href="show_bug.cgi?id=164#c201">comment #201</a>)
<span class="quote">&gt; For those of us who are less technical, but keen to see this bug resolved, is
&gt; there somewhere where we can submit alphabets, so that they may be added for
&gt; collation? I.e. where we submit the sorting order of specific languages for use
&gt; with {{sort:en}} (or whatever the mark-up will be)?</span >

We'll be using some kind of pre-rolled algorithm from CLDR or such, so you don't need to do this.  If the deployed algorithm turns out to be deficient, and it's not a bug on our side, you should probably contact CLDR, not us.

(In reply to <a href="show_bug.cgi?id=164#c203">comment #203</a>)
<span class="quote">&gt; May I even suggest that the name of the new column does not even use &quot;sortkey&quot;
&gt; 
&gt; i.e. &quot;cl_sort_prefix&quot; instead of &quot;cl_sortkey_prefix&quot;
&gt; 
&gt; Why? because this column should NEVER need to convert that prefix itself to a
&gt; binary sortkey, it should just still be the humane-readable prefix that was
&gt; specified in {{DEFAULTSORT:sort_prefix}} or in [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3A...">Category:...</a>|sort_prefix]].</span >

Yes, this stores the plaintext, unconverted prefix.  I don't think the name needs to be changed, though.  Both names work well enough.

<span class="quote">&gt; This will avoid confusion, but it will also allow simpler recomputing of actual
&gt; sortkeys for various locales, without having to parse the page again for each
&gt; locale:</span >

Yes, that's intended to work.

<span class="quote">&gt; Note that when evaluating and expanding the parameters of
&gt; {{DEFAULTSORT:sort_prefix}} and of [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Category%3A...">Category:...</a>|sort_prefix]] in the wiki
&gt; code of a page (or when transcluding templates), the result text should NEVER
&gt; depend on the UI language (so if {{int:lang}} is used in that parameter, it
&gt; should evaluate always as if it was {{CONTENTLANGUAGE}}).</span >

If people want to put crazy stuff in sortkeys that changes based on who's viewing it, we can't stop them.  Curly braces are evaluated at an earlier stage than category links, so we can't make them behave differently based on whether they're being used in a sortkey, I don't think.  You could also put {{CURRENTTIME}} in sortkeys, or any other silly thing like that.</pre>
    </div><div id="c205" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c205">Comment 205</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-08-04 17:09:44 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c204">comment #204</a>)
<span class="quote">&gt; If people want to put crazy stuff in sortkeys that changes based on who's
&gt; viewing it, we can't stop them.  Curly braces are evaluated at an earlier stage
&gt; than category links, so we can't make them behave differently based on whether
&gt; they're being used in a sortkey, I don't think.  You could also put
&gt; {{CURRENTTIME}} in sortkeys, or any other silly thing like that.</span >

That's because the Mediawiki parser still operates on the wrong level, and performs text subtitutions always without ingoring the context of use. Not only this is bad, but this is also very inefficient, because each processing level is converting a fullpage to another fullpage that needs to be reparsed again at the next level.

A much better scheme based on a true gramatical analyser using a finite state automata would really help defining the state at which the parser (or its ParserFunctions extensions) operate, without ever having to create huge complete page buffers between each level (which uses costly appending operations with many memory reallocations).

In other words, when you start parsing &quot;[[&quot; you enter in a &quot;start-of-link&quot; state, which then parses &quot;category:&quot; until it has found a colon, in which case the whole prefix is case-folded and goes to the &quot;in-category&quot; state, then the parser scans up to the next &quot;{&quot; or &quot;|&quot; or &quot;]&quot;. It can then correctly process all the text using such rules.

I have suggested since long that the MediaWiki syntax should be reformulated using a LALR(1) formal syntax, from which a finite-state automata can be automatically built to cover all the state information, and then ported to PHP (Yacc, Bison or even better PCTCS could do that without difficulty). Then instead of calling parsing functions that process all the text, then return the converted text for processing to the next level, it will do that in a much simpler (and faster) processing loop, calling much simple generation methods and altering its state in a much cleaner and faster way (no more need to append small lexical items to various buffers, the atoms will be pased from level to level using a chained implementation.

This would also significantly speedup the expansion of templates, and would allow the parser to make distintions when {{int:....}} is encountered in the context of a [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>]] (which would have temporarily forced the UI language to the CONTENTLANGUAGE, until the final &quot;]]&quot; token is encountered that would restore the UI language within the parser's internal state. this would also have significant performance benefits (for example, no more need to convert and expand all the parameters of {{#if:...}} or {{#switch:...}}, only convert them lazily when they are really needed for generating the effective output.

Yes this comment is going too far out of the topic of this bug, it is architectural. PHP has all the rools needed to support the construction of tree-like data: instead of passing only strings to parser generation functions, you would pass it an ordered array, whose elements are the parsed parameters, themselves being either strings or subparsed arrays containing strings and other arrays. The builtin functions would then request back to the MediaWiki parser the evaluation/expansion of ONLY the parameters they need, and MediaWiki would still be able to call the expansions of ONLY these parameters, recursively. Most of the items in the wikicode would then be atomic and processed lazily, only when they are effectively needed.

The &quot;crazy&quot; things like {{CURRENTTIME}} or {{time:...}} or {{int:...}} found within [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=category%3A...">category:...</a>]] and whose result depends on time or on user preferences would be easily avoided. This would also simplify a lot the management of whitespaces (if they need ot be trimmed and/or compressed depends on the builtin expansion function called by the parser.</pre>
    </div><div id="c206" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c206">Comment 206</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-08-04 17:14:25 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c205">comment #205</a>)
<span class="quote">&gt; That's because the Mediawiki parser still operates on the wrong level, and
&gt; performs text subtitutions always without ingoring the context of use. Not only
&gt; this is bad, but this is also very inefficient, because each processing level
&gt; is converting a fullpage to another fullpage that needs to be reparsed again at
&gt; the next level.</span >

People have tried to fix this before, and failed miserably.  It is not practical in the immediate future, if ever.  Everyone likes to say how great it would be to write a &quot;real&quot; parser, but nobody ever seems interested in producing working code that actually replicates the current parser to a good enough level to maintain acceptable backward compatibility.  If you're interested in that, please give it a try and get in touch with us when you have a working implementation.  Otherwise, it's not worth discussing pointlessly yet again.</pre>
    </div><div id="c207" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c207">Comment 207</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-08-04 17:41:52 UTC
        </span>
      </div>



<pre class="bz_comment_text" >In reply to <a href="show_bug.cgi?id=164#c206">comment #206</a>)
Top-down analyzers are very easy to write, provided that you allow parsing to be made via TWO generation points, instead of one: the first one converts and accumulates the tokens in an array as long as it is not able to be processable as a whole; this requiers a first parsing loop. Then the final step will ask the expansion of parsed tokens lazily, in a basic processing loop which will &quot;eat&quot; the tokens lazily, replacing them by their expansion, until there remains only one token, a basic string that can be used as an expanded parameter.

I may try working on it, it's not so complicate to formulate, even without using Yacc/bison/PCTCS, I have many ideas on how it will work : basically each non-terminal token in the formal syntax becomes TWO functions, one is used when parsing individual tokens, until the last one is reached, then a second function will be used to expand itself, that will be used later (after returning from the  BY the caller, and ONLY when it will need the expansion in its OWN expansion function.

For example the MediaWiki parser would become TWO functions: mediawiki_parse() (which returns an array of tokens) and mediawiki_expand() which is stored as the first token in the array. All ..._expand() functions would have two parameters: one for the context in which they are to be evaluated (containing for example time properties, cache properties, language properties ), and the array itself to be expanded up to the end until they produce some simple text The main concept is that tokens will expand lazily, but with full control by the non-terminal parsed token which knows its context of expansion.

Basically the first step for each non-terminal token in the formal grammar is performing a bottom-up conversion, from a top-down analysis (performed recursively); this first step builds a AST tree (stored as a basic array of children). The second step is performing a *conditional* top-down expansion of the AST array into a flat text, ignoring nodes that don't need to be expanded as their effective expansion will not be needed for the expansion of the current AST node. Both steps are recursive, but in separate simple processing loops.

OK this is still out of topic, but I don't know for now where to post these concepts. I'll stop discussing this here.</pre>
    </div><div id="c208" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c208">Comment 208</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-08-27 00:27:48 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Invalid sorting (collation problem)"
   href="show_bug.cgi?id=24953">Bug 24953</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c209" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c209">Comment 209</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Chad H.</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2010-09-10 17:53:07 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Alphabetization of categories in Turkish Wikimedia projects"
   href="show_bug.cgi?id=25129">Bug 25129</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c210" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c210">Comment 210</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Roan Kattouw</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-03-09 13:58:51 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Simplify default sortkey for portuguese (better collation support for categories)"
   href="show_bug.cgi?id=24142">Bug 24142</a> has been marked as a duplicate of this bug. ***</pre>
    </div><div id="c211" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c211">Comment 211</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mark A. Hershberger</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-03-19 04:03:09 UTC
        </span>
      </div>



<pre class="bz_comment_text" >On wikitech-l, Roan writes 

<span class="quote">&gt; This support is now in MW with the category collation code Aryeh
&gt; wrote, and developers can now proceed to write language-specific
&gt; collations if they want to.</span >

See <a href="http://permalink.gmane.org/gmane.science.linguistics.wikipedia.technical/52572">http://permalink.gmane.org/gmane.science.linguistics.wikipedia.technical/52572</a></pre>
    </div><div id="c212" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c212">Comment 212</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Lejonel</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-15 19:53:46 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c211">comment #211</a>)
<span class="quote">&gt; On wikitech-l, Roan writes 
&gt; 
&gt; &gt; This support is now in MW with the category collation code Aryeh
&gt; &gt; wrote, and developers can now proceed to write language-specific
&gt; &gt; collations if they want to.</span >

So other collations are possible for categories. But this bug is also about sorting in other places. Is there any support for sorting lists in special pages? For example duplicate <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED DUPLICATE - Danish letters has wrong sort order"
   href="show_bug.cgi?id=353">bug 353</a> is about Danish letters in Special:Allpages.</pre>
    </div><div id="c213" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c213">Comment 213</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-15 20:12:10 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Getting sorting working in other places would require work, but we could use the same infrastructure.  For Special:Allpages, we'd need to add an extra column and index to the page table, which seems a bit excessive for such a minor special page.</pre>
    </div><div id="c214" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c214">Comment 214</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Niklas Laxström</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-16 11:51:15 UTC
        </span>
      </div>



<pre class="bz_comment_text" >There are lots of places where pages are listed - don't they also require or benefit form such index?</pre>
    </div><div id="c215" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c215">Comment 215</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-17 14:12:58 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Maybe.  It depends.  Given the number of comments here and the number of people being spammed on every post here, though, I'd strongly suggest that people open new bugs for each place they want to have improved collation, rather than continuing to use this bug.  You can mark them as depending on this one so interested parties can find them.</pre>
    </div><div id="c216" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c216">Comment 216</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-17 16:50:16 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Aryeh, Can you point me with a link where your implementation was added in MW ? I'd like to review it, and locate possible bugs or caveats.
Also because the announces integration does not give documentation details about how we can use it (Wiki code syntax in pages, possible support templates, integration points, server settings, possible user preferences, possible parser functions for generating helper data in the HTML so that collation will also work on the browser side because there's still no support anywhere of collation in Javascript and because most Javascript code found to handle special sorts are bogous and do not implement true UCA, except some HTML/Javascript applications using Ajax requests to perform sort on the server side).

---

Note: jQuery still does not have any &quot;utility&quot; function to support collation. It provides a &quot;.sort()&quot; method that requires a callback function in parameter to perform the actual compare(), but inefficiently as it still cannot use precomputed collation keys from actual table data, so the user-supplied compare function would recompute collations many times from the same data cell, while performing the sort).

I have asked to jQuery to extend its interface to allow precomputing collation keys in a first pass using a user-supplied callback, and then only supply these precomputed collation keys when comparing cells during the actual sort, but this is still a dead letter. I have also asked to jQuery to start a project for implementing a $.CollatorFactory object from which collators can be prepared and instantiated, and a common interface for these collators returned by the factory.

jQuery should then supply at least a very basic CollatorFactory (a stub implementing only binary sort). Then a separate subproject could start creating a more complete CollatorFactory that will fully support multiplevel UCA, that will integrate the DUCET table, and that will integrate support for locale-specific tailorings of the DUCET, before integrating a collection of tailorings (based on CLDR data, but not necessarily on the same format, and not necessarily by allowing a dynamic instantiation of any kind of tailoring using the CLDR syntax for them.

Note that the collection of tailorings (there are many locales in the CLDR) need not always be fully loaded into the browser Javascript: a server-side Ajax request could as well provide the necessary data to the browser (most probably in a JSON structure), for allowing tailored collators to be instantiated rapidly without having to parse the CLDR syntax).

The DUCET table dataset (most probably large) could as well be loaded to the browser in a delayed way as well through Ajax only on demand (and possibly only a part of it, under the control of the CollatorFactory sollicitated by specific collators that would just ask to the CollatorFactory to preload some segments of it, to save page load time and volume, and only when the Javascript will start running some collation function that requires this data to have been initialized and loaded.

I'd like to start my own project for that, and integrate it to jQuery, in a much better way than all what I've seen on the web (all the implementations I've seen for support of collation in Javascript are simply bogous, or at least very defective). Unfortunately, Javascript itself (or the most recent ECMAScript specification), has completely forgotten to develop the subject of collation, so it will take many years before we get correct browser-side sorting becoming standard in browsers: there's not even any ongoing project for that, or even just some preliminary specs, either at ECMA, or at W3C, Apache, jQuery... and even at Oracle, Microsoft, Apple, Mozilla and Opera).

Such support on the opposite is already present in Adobe Flash, in Microsoft's Silverlight (based on the .Net libray), and since many years in Java. This means that ALL web applications that want correct browser-side collation still need to run with browser plugins, and not with pure Javascript over the HTML/CSS DOM API. Given the ongoing efforts to deprecate these plugins in favor of HTML5, I don't understand why no such effort has ever been initiated.</pre>
    </div><div id="c217" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c217">Comment 217</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Aryeh Gregor (not reading bugmail, please e-mail directly)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-18 18:25:02 UTC
        </span>
      </div>



<pre class="bz_comment_text" >The interesting code is here:

<a href="http://svn.wikimedia.org/viewvc/mediawiki/trunk/phase3/includes/Collation.php?view=markup">http://svn.wikimedia.org/viewvc/mediawiki/trunk/phase3/includes/Collation.php?view=markup</a>

That's the part that does the actual collation, which is really just handed off to the intl extension.  The part that actually hooks into category pages is in CategoryPage.php, but it's relatively boring.  I don't think there are any parser functions or anything else exposed to users right now.

If you have questions or comments, I strongly encourage you to post to wikitech-l, not this bug.  Bugzilla is used for bug tracking, not discussion, and this bug is fixed.  If you have further feature requests, like the addition of new parser functions that expose the sortkey functionality, file new bugs.  I am not going to answer any questions that are asked here.</pre>
    </div><div id="c218" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c218">Comment 218</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 08:54:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >OK, I immediately found a bug in the binary search function (which is defintely not beinary, has slower than expected convergence, and may even stale on testing the same index, due to incorrect handling of min/max indice after comparing):

291     function findLowerBound( $valueCallback, $valueCount, $comparisonCallback, $target ) {
292	                $min = 0;
293	                $max = $valueCount - 1;
294	                do {
295	                        $mid = $min + ( ( $max - $min ) &gt;&gt; 1 );
296	                        $item = call_user_func( $valueCallback, $mid );
297	                        $comparison = call_user_func( $comparisonCallback, $target, $item );
298	                        if ( $comparison &gt; 0 ) {
299	                                $min = $mid;
300	                        } elseif ( $comparison == 0 ) {
301	                                $min = $mid;
302	                                break;
303	                        } else {
304	                                $max = $mid;
305	                        }
306	                } while ( $min &lt; $max - 1 );
307	
308	                if ( $min == 0 &amp;&amp; $max == 0 &amp;&amp; $comparison &gt; 0 ) {
309	                        // Before the first item
310	                        return false;
311	                } else {
312	                        return $min;
313	                }
314	        }

The authout should have better read how TESTED binary searches are implemented. This should really be:

    function findLowerBound( $valueCallback, $valueCount, $comparisonCallback, $target ) {
        $min = 0;
        $max = $valueCount - 1;
        while ( $min &lt;= $max ) {
            $mid = ($min + $max) &gt;&gt; 1;
            $item = call_user_func( $valueCallback, $mid );
            $comparison = call_user_func( $comparisonCallback, $item, $target );
            if ( $comparison &lt; 0 ) {
                $min = $mid + 1;
            } elseif ( $comparison &gt; 0 ) {
                $max = $mid - 1;
            } else {
                return $mid; // or: $max = $mid; break;
            }
        }
        // $target not found, now $max &lt; min (more exactly, $max = $min - 1).
        // $target is to insert between them: $max is the highest lower bound.

        if ( $max &lt; 0 ) {
            // Before the first item
            return false; // Don't test with a simple if !
        } else {
            return $max; // May return 0 (lower bound on first item)
        }
    }

Note that the final test to return false is unnecessary and causes confusion on usage (if you had written this in C/C++ instead of PHP, you would not be able to make the distinction between false (no lower bound not found) and 0 (valid lower bound). Your code should not depend on those PHP hacks, which consists in returning values of distinct types (but with PHP's implicit promotion on basic types, it's really dangerous do do that) !

It's just simpler to let it return -1 (the content already in $max when we are before the first item), and then let the caller test the negative sign of the result, instead of comparing it then with false.</pre>
    </div><div id="c219" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c219">Comment 219</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 11:20:08 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I note the following comment in <a href="https://www.mediawiki.org/wiki/Special:Code/MediaWiki/80443" title="revision 80443 in SVN">r80443</a>:
* Changed Title::getCategorySortkey() to separate its parts with a line break instead of a null character. All collations supported by the intl extension ignore the null character, i.e. &quot;ab&quot; == &quot;a\0b&quot;. It would have required a lot of hacking to make it work.

If you had read my comments above, I had already spoken since long about the choice of the separator to use between the prefix and the rest of the full page name: this had to be a non-ignorable character, that is clearly lower than any character usable in the full pagename.

I had also stated which character to use, namely the TAB character that is the first non-ignorable (i.e. with non-all-zeroes weights). See my <a href="show_bug.cgi?id=164#c190">Comment #190</a> for the rationale (one year ago, much longer before your recent fix to use LF, because before yu had tried with NULL, which was wrong, and even without any separator which was also wrong).

You could have avoided these bugs, as I had analyzed it long before.

OK, LF (U+000A) is OK (because it is not allowed in full page names), even it is not the first one.

---

One word for performance and space: you have put too many fields in table &quot;categorylinks&quot;. Only one essential think is needed there for referencial constraints and counting: the UNIQUE index on (cl_from, cl_to), which is architectural. As this index is unique, it should share the same store as the table itself. But SQL engines will never use more than one index per table to read it, because it requires additional random-access cursors to access the table. As the current unique index uses less fields than the table, it implicitly creates a random-access reference from this index to the table (basically, using internal rowids stored in the index, instead of reading directly from the table).

To avoid this problem, you have to make sure that the table is formatted so that its first fields match exactly the same order as the unique index. This is the case for the first unique index created just after that. So the table and the index share the same store, however the number of rows in the index per storage page will be limited (the table can use up to 1KB per row, this does not give a very compact and fast search in the index, as it will load too many storage pages in memory, even when using a &quot;very&quot; selective search).

You may optimize searches (at the price of storage space), by indicating that the unique index should still use a separate store. Normally this is the role of the specifier &quot;PRIMARY&quot; which indicates to not use a separate store (it is still UNIQUE). For now you don't have any PRIMARY index, only a UNIQUE index which only uses a separate index store.

Now comes the two main kind of requests performed by MediaWiki:

(1) getting the list of categories in which a page is currently listed (including when saving a page because this list must be flushed out and replaced by the categories found when parsing the page). Ideally, this should require at least an index on the cl_from. The UNIQUE index on (cl_from,cl_to) works perfectly there because it is in separate store. Other attributes in the table will not even be read, unless the SQL query wants to get these attributes (if this is the case, both the index and table store will be read, the index being read very rapidly and joined with the table using the internal table row id, stored in the index with the two keys). In all what I have seen in the MediaWiki code, this does not occur (including when rendering a page, to display the list of categories, it just needs this list but gets it from the page's wiki code parsing before saving it, and this gets saved in the page cache).

(2) getting the list of pages in a category. There you need to use collation as well because this list is sorted. Ideally, this should use an index and table that just contain the necessary fields, and that the SQL SORT BY clause will use those same fields, in the same order (and either all in ASCENDING, or all in DESCENDING order). This is the second index:

CREATE INDEX /*i*/cl_sortkey ON /*_*/categorylinks (cl_to, cl_type, cl_sortkey, cl_from);

Obviously, it cannot use the same index store as the table. The introduction of the &quot;cl_type&quot; field is recent. It supposes that you will be paging the category views by page type, in the order set by cl_type, which is:
ENUM ('page', 'subcat', 'file').

I wonder if this is correct and if it's the expected order. But anyway this design means that the current code will actually perform three separate requests, each one will be paged separately: one request to get the list of normal pages, another to get the list of subcats, and another to get the list of files. This will be inefficient, and hard to manage for the paging, unless these three types can be effectively paged separately in the MediaWiki HTML UI (this is not the case, as of today).

So if we can only do paging on all categorized pages, whatever their type, the &quot;cl_type&quot; field in the index causes the &quot;SORT BY cl_sortkey&quot; clause in the SQL query to build a clostly temporary index, instead of reading directly from the index where it will finally get the &quot;cl_from&quot; field to display.

So as long as we cannot have separate paging by type, I really suggest that you either drop the &quot;cl_type&quot; field from this index, or that you place it after &quot;cl_sortkey&quot; needed for fast &quot;ORDER BY&quot;. I.e. :

CREATE INDEX /*i*/cl_sortkey ON /*_*/categorylinks (cl_to, cl_sortkey, cl_from);

My opinion if that &quot;cl_type&quot; is not even needed there, the page id stored in &quot;cl_from&quot; already has this information, because it will be always be used as a reference to the &quot;pages&quot; table to get the actual page name to display, as well as its namespace, none of them being stored in the &quot;categorylinks&quot; table itself. 

Note that because this is a secondary index (in a separate store), it is still good to include 'cl_from' there, even if it's not needed for the selectibity of this index, just to avoid an additional random-access cursor to the &quot;categorylinks&quot; table to be used by the SQL engine using table row ids also stored in this index (SQL engines prefer to use referencial cursors, if possible, instead of creating temporary table/index stores for cross joins between tables and/or indexes, except if both joined parts are not very selective ; as this is SQL-engine specific to their internal query optimizer, I won't discuss more about the tricky details ; it's just simpler to avoid the selectivy problem here by including the small &quot;cl_from&quot; field in this index which does not fill up much space in the encoded index row and still allows a good compaction of many rows in the index pages).

So why &quot;cl_type&quot; is there (in the index) if we still cannot perform paging separately on these types when viewing a category content ? Even if you do so later, it will require  separate SELECT requests, with separate sorts, and separate paging every 200 items. In this case only, &quot;cl_type&quot; will be specified as a constant and will become very selective, and probably better viewed with separate indexes (so even &quot;cl_type&quot; will not be needed if you have separate tables by splitting the &quot;categorylinks&quot; table for each type).

If you really want to maintain the &quot;cl_type&quot; field, for me it's just an informational denormalization of something really represented by &quot;cl_from&quot;. Beware of the effects of such denormalizations (I hope that a page id will never  change its type, including when a page is renamed to another namespace; but I won't bet it; I think this may be the cause of future database inconsistencies). For me the rest of the datashema is not prepared to handle such separation (notably between cl_type=&quot;page&quot; and cl_type=&quot;file&quot;).

And in fact if you really want to maintain it in the index, as a convenience to simplify the MediaWiki client code perorming the SQL queries, it should better be, for now, only the last field of this index:

CREATE INDEX /*i*/cl_sortkey ON /*_*/categorylinks (cl_to, cl_sortkey, cl_from, cl_type /* denormalized: see cl_from */);

This will still avoid the ORDER BY clause of your queries to create an expensive temporary index when viewing and paging the (sorted) contents of a category (notably for very populated categories, notably on Wiktionnaries that contain categories for large collections of words per language, with 200 000 entries or more).</pre>
    </div><div id="c220" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c220">Comment 220</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Tim Starling</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 12:14:54 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c218">comment #218</a>)
<span class="quote">&gt;             if ( $comparison &lt; 0 ) {
&gt;                 $min = $mid + 1;
&gt;             } elseif ( $comparison &gt; 0 ) {
&gt;                 $max = $mid - 1;</span >

The function is not a classical binary search, which only determines equality, instead it finds the lower bound of a range. When the test item sorts below the target ($comparison &lt; 0), it can't be ruled out as a prospective lower bound. That's why you need $min = $mid, not $min = $mid + 1. 

Maybe $max = $mid - 1 is possible in the $comparison &gt; 0 case, with your suggested alteration to the test for the before-the-start case. But the existing code is tested and does work, and the improvement in convergence rate would be small. 

<span class="quote">&gt; OK, I immediately found a bug in the binary search function (which is defintely
&gt; not beinary, has slower than expected convergence, and may even stale on
&gt; testing the same index, due to incorrect handling of min/max indice after
&gt; comparing):</span >

I assume by &quot;stale&quot; you mean an infinite loop. This does not occur because the midpoint is always different from either of the two endpoints until the difference $max - $min is reduced to 1 or 0, at which point the loop exits. 

In a textbook binary search, offsetting the midpoint by 1 allows the loop to continue until $min &gt; $max. But as I said, we can't offset the midpoint in the $comparison &lt; 0 case, so a slightly earlier loop termination is required to avoid an infinite loop.

<span class="quote">&gt; Note that the final test to return false is unnecessary and causes confusion on
&gt; usage (if you had written this in C/C++ instead of PHP, you would not be able
&gt; to make the distinction between false (no lower bound not found) and 0 (valid
&gt; lower bound). Your code should not depend on those PHP hacks, which consists in
&gt; returning values of distinct types (but with PHP's implicit promotion on basic
&gt; types, it's really dangerous do do that) !
&gt; 
&gt; It's just simpler to let it return -1 (the content already in $max when we are
&gt; before the first item), and then let the caller test the negative sign of the
&gt; result, instead of comparing it then with false.</span >

It's conventional for PHP functions to return false to indicate an error or other unusual situation, see for instance <a href="http://php.net/array_search">http://php.net/array_search</a> . It's not at all dangerous. If I wrote the function in C, I would indeed have used -1, and I would have called it an ugly hack to work around C's lack of weak typing.

If you're aware of some actual bug in findLowerBound(), you should file a separate bug report, or note it on &lt;<a href="http://www.mediawiki.org/wiki/Special:Code/MediaWiki/80443">http://www.mediawiki.org/wiki/Special:Code/MediaWiki/80443</a>&gt;</pre>
    </div><div id="c221" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c221">Comment 221</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Domas Mituzas</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 12:40:40 UTC
        </span>
      </div>



<pre class="bz_comment_text" >&#64;Philippe, InnoDB treats first UNIQUE index as clustered PRIMARY key, which stores all data with it (I assume you don't come from InnoDB background, please correct me otherwise ;-)

cl_sortkey structure allows having dataset split by type (e.g. subcategories first, files last, whatever), and still maintain decent sorted order. cl_from is included for cases where we need to page over multiple entries with same sortkey.

do note, as secondary keys would include primary key values anyway, it is not much of a cost. 

Back in the day both major reads used to be covering ones, without random lookups, I'm not sure if there's a regression nowadays with all the new collation code though.</pre>
    </div><div id="c222" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c222">Comment 222</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 13:18:31 UTC
        </span>
      </div>



<pre class="bz_comment_text" >You should know that a binary search for equality of for lower bound is completely the same algorithm. (If not convined, look at the source of a C++ standard library, which uses the same function for both: finding exact matches or finding a lower bound for inserting a new item).

The difference only occurs at end of the loop, about what you return when an exact equality is not found. In both cases, the binary search loop will terminate with min=max+1 exactly if no exact match is found, so that max is the lower bound you want.

My suggestion fixes a few things:
- it uses a while()... instead of a do...while() which is incorrect for the case where the search space opperates with count&lt;2.
- it has faster convergence
- it contains no special case to handle (your code will be erroneous in those cases).
- even when searching with count=0, it starts with min=0 and max=-1, which terminates the loop immediately, with the same condition for not found (max &lt; min, and max if the lower bound)
- it works with count=1 without creating an infinite loop like in your code when the target is higher that the only element [0] to check, because it ensures that the loop will ALWAYS reduce the search space at each interation.</pre>
    </div><div id="c223" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c223">Comment 223</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-07-20 13:35:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt; The function is not a classical binary search, which only determines equality,</span >
instead it finds the lower bound of a range. When the test item sorts below the
target ($comparison &lt; 0), it can't be ruled out as a prospective lower bound.

And here you're completely wrong : in that case the comparison says that the mid idem is certainly not the lower bound. Don't forget that the item at max (and below) will also be tested: max will decrease as well, up to the point that it will either find an exact match, or will fall 1 position below min.

<span class="quote">&gt; That's why you need $min = $mid, not $min = $mid + 1. </span >

That's why you don't need that !</pre>
    </div><div id="c224" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c224">Comment 224</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Brion Vibber</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-24 20:25:53 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I'm reopening this based on notes from <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a> etc.

* The fixes applied for this bug apply only for category member sorting, but the problem exists in many other places as mentioned in the summary, such as [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Special%3AAllpages">Special:Allpages</a>]], [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Special%3AListUsers">Special:ListUsers</a>]], etc

* There doesn't appear to be any straightforward way to set the collation to a locale-specific one!

The only available options are &quot;uppercase&quot; and &quot;uca-default&quot; -- sorting in a locale-specific way (say, Swedish per <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a>) appears to require writing additional code

* For some reason, site content language doesn't appear to be taken into account in any way; you must set $wgCategoryCollation manually.

This seems very strange to me, and is an obvious additional burden on site administrators to figure out how to code up (!) and then activate a language-specific collation.</pre>
    </div><div id="c225" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c225">Comment 225</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Siebrand Mazeland</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-24 20:55:21 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c224">comment #224</a>)
<span class="quote">&gt; I'm reopening this based on notes from <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a> etc.
&gt; 
&gt; * The fixes applied for this bug apply only for category member sorting, but
&gt; the problem exists in many other places</span >

Don't forget sortable table sorting.

I'm not sure if this bug with 224 (225 now) comments is the best bug to keep tracking this. How about creating a tracking bug, and slicing this issue into smaller, more manageable issues?</pre>
    </div><div id="c226" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c226">Comment 226</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Bawolff (Brian Wolff)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-24 22:40:39 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c224">comment #224</a>)
<span class="quote">&gt; I'm reopening this based on notes from <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a> etc.
&gt; 
&gt; * The fixes applied for this bug apply only for category member sorting, but
&gt; the problem exists in many other places as mentioned in the summary, such as
&gt; [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Special%3AAllpages">Special:Allpages</a>]], [[<a href="https://en.wikipedia.org/w/index.php?title=Special:Search&go=Go&search=Special%3AListUsers">Special:ListUsers</a>]], etc</span >

Related <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Sort order in Special:ListUsers should be case-insensitive"
   href="show_bug.cgi?id=24574">bug 24574</a>. I suppose we would have to add a sortkey field to other various table.

<span class="quote">&gt; * There doesn't appear to be any straightforward way to set the collation to a
&gt; locale-specific one!
&gt; 
&gt; The only available options are &quot;uppercase&quot; and &quot;uca-default&quot; -- sorting in a
&gt; locale-specific way (say, Swedish per <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a>) appears to require writing
&gt; additional code
&gt; 
&gt; * For some reason, site content language doesn't appear to be taken into
&gt; account in any way; you must set $wgCategoryCollation manually.</span >

I think that was partially out of concern for php installs without the intl extension installed (So uca collation would not work). Since changing the collation requires running a maintenance script, if we just checked that the relevant class existed to determine which collation to use, and then someone upgraded their php so intl was suddenly present, things would become screwed up. (Or that's what I assumed the reasoning was. I could be wrong)

<span class="quote">&gt; 
&gt; This seems very strange to me, and is an obvious additional burden on site
&gt; administrators to figure out how to code up (!) and then activate a
&gt; language-specific collation.</span >

Perhaps making the value $wgCategoryCollation consider anything past uca to be the locale. For example it would consider the value of &quot;uca-foo&quot; to use IcuCollation( 'foo' ) as the Collation class.</pre>
    </div><div id="c227" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c227">Comment 227</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Purodha Blissenbach</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-25 16:02:59 UTC
        </span>
      </div>



<pre class="bz_comment_text" ><span class="quote">&gt; (In reply to <a href="show_bug.cgi?id=164#c224">comment #224</a>)
&gt; 
&gt; Don't forget sortable table sorting.</span >

Sortable tables are sorted client-side. This might offer additional
flexibility. If clients were enabled to choose collations for sortable
tables at the time of accutal sorting, we could offer them options
above those available in server side database sorts.</pre>
    </div><div id="c228" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c228">Comment 228</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-26 21:49:23 UTC
        </span>
      </div>



<pre class="bz_comment_text" >I am currently working on a Javascript implementation of UCA (i.e. with full support of the DUCET, at least 4 collation levels, and support for language-based tailorings). This is a very difficult task if we need performance. The trick is to use efficient lookup tables, but the difficulty is being able to update them (for tailorings); also performance will highly depend on how the DUCET is represented in Javascript, so that it can be initialized sufficiently fast that you won't notice this init time, when a collator object gets instanciated.

I'm still not sure that performance will be good enough (even with today's much faster Javascript implementations), and may be some optional cooperation with a server-side script will be needed (or possibly by using a client-side native plugin interfaced with Javascript, such as Flash) could limit the number of JSON requests to a server in order to provide the tailored lookup tables. How to detect ans use client-side plugins in an open way.

I really hope that someday, the Javascript/ECMAScript standard will specify a common standard interface to collators. I've already looked for help from authors of jQuery, where such common interface would become part of its &quot;tools&quot; library (even if this has nothing in common with working in the HTML DOM, that is the main focus of jQuery).

For now there exists absolutely no reliable implementation of UCA in Javascript working only on the client-side (but there does exist already some Javascript libraries that in fact use JSON or XML requests to a server, in order to build or retreive the necessary lookup tables).

For practical reasons, a server-side JSON/XML request could be optimized to reduce the volume of data exchanged (for example by providing only some parts of the collation elements, these data being then requested on demand even after the collator has already been -partly- initialized, and then cached in the collator object). But this is a complication in the design that for now I don't want to investigate too early, before I get a good image of the performances effectively needed in practice.

May be it will be just enough to initialize only a part of the DUCET for a particular language and its specific tailoring, sorting all the other many characters with default weights (not necessarily from the large DUCET).

My implementation will provide at least 3 interfaced functions:
- instantiating a collator for a given language &amp; sort order
- computing collation keys from strings, for more efficient sorts of large tables (even if we use a QuickSort, the same strings are compared multiple times with other strings, so it may help to compute their collation keys only once); in addition, it may not be necessary to compute the full collation key, but only keys up to the level that's sufficient to perform a specific compare; collation keys can then be computed partly, on demand, and cached, instead of being fully computed for the full string at all collation levels; in addition, not all table sorts may require the maximum collation level supported, so collation keys don't necessarily have to be long (in memory);
- the tradeoff for precomputing keys instead of compring keys on the fly, is highly dependant with the table sizes: for small number of rows to be sorted, you gain little with precomputed keys, you just waste memory and get lower performance. So the interface will also include a 3rd function: comparing strings using this collator, without necessarily having to compute the collation keys.

I estimate that the tradeoff limit between precomputed collation keys and direct compares is for tables of about 100 rows, for which it may be helpful to provide a very fast response time when sorting them, but I may be wrong, because these small tables will not require precomputing and storing a lot of collation keys (so this first step before the QuickSort loop may be insignificant). The real limit could be memory use in very large tables for precomputing, storing or caching the collation keys; but such very large tables will probably be very uncommon in tables generated from Wiki pages (most of these tables would not include more than 500 rows, and storing 500 collation keys is not really a problem in today's browsers, except possibly in smartphones with limited memory resources and slow processors, compared to laptops, notebooks and tablets).</pre>
    </div><div id="c229" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c229">Comment 229</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andrew Dunbar</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-27 10:03:28 UTC
        </span>
      </div>



<pre class="bz_comment_text" >&#64;Philippe Verdy: I think work on the bigger Unicode problems for JavaScript is pretty important. I tried to file a bug or feature request somewhere a couple of years ago and the sentiment from the js community was that Unicode was too big and  unneeded, would bloat js and be too slow. I couldn't convince whoever was my audience that you just need it and in any case the js implememtations should be hooking into Unicode APIs provided by their host OS or browser which must have them anyway.

I have implemented some character/script property stuff from Unidata in js and for my purposes found it very fast indeed to do everything with binary search. And all the js implementations are much faster now.

I was doing stuff like looking up the script of every character in an HTML page.

I've also implemented internationalized sorting including UCA of page titles in en.wiktionary using the toolserver as a back end. All work was done on a first generation netbook (-: You have my support. Is there somewhere I can watch your project perhaps?</pre>
    </div><div id="c230" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c230">Comment 230</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-27 11:06:18 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Until recently, it was too slow to initialize a large table like the DUCET. But now that Javascript starts being used for 2D/3D rendering with interactive speed, demonstrating complex animations, I don't think this is a performance issue. The only issue is the code size that must be loaded once (that's why I spoke about caching the DUCET and loading it by parts, on demand). But note that the DUCET is not as large as the full Unicode. You can easily exclude the Hangul syllables, and the sinograms, and can autobuild some parts of it for blocks of symbols. The core of the implementation is already written for the DUCET-based collation, I need more work to instantiate tailorings. But I've not determined the best way to handle on-demand loading of the DUCET. In addition, if I can finalize it, I will need a way to regenerate with some automatic tool the representation of the DUCET for each release of Unicode. For now I just use a static table, created with lots of manual operations: a code generator will be needed (just like in all existing full implementations of UCA).</pre>
    </div><div id="c231" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c231">Comment 231</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Bawolff (Brian Wolff)</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-28 23:35:55 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Re JS sortable table stuff (this bug is about too many things...): Well client side js sorting stuff would be nice, since these tables aren't dynamic, wouldn't it be easier to: on the server side add a sortkey as a data attribute for each cell of the table, and then just sort that on client side. (Only issue with this is it might be complicated to implement in the parser [table code in parser is scary imho, but I'm sure some other people find it less scary], and lang preferences, but I think that just using the content language [or the page's language I suppose now that we have that] would be sufficient).

Thoughts?</pre>
    </div><div id="c232" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c232">Comment 232</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-08-29 01:29:45 UTC
        </span>
      </div>



<pre class="bz_comment_text" >If table contents are static, it's true that their collation weights could be delivered as well with the visible table.

In a past message above, I had already proposed that the function that already is needed to sort categories, and that computes the UCA collation keys, would be exposed as a ParserFunction. This would then obviously allow any wiki page to compose web tables containing both the visible data and the associated collation key.

Many very complex templates, that are used to generate sortable pseudo-collation keys would no longer be needed or would be largely simplified. In fact, I even proposed initially to first expose this function before even modifying the schema of categories : there was no immediate mergency to modify this schema, as long as we could experiment assigning sort keys when categorizing a page, using that ParserFunction.

And probably we would have been able to experiment with a better schema, including one that would have allowed multiple collation keys (generated from different locale parameters), something that has been forgotten completely (and that will require a new change in the database schema in the future, to support multiple collations according to users localisation preferences (and expectations).

Anyway, my work on JS implementation of UCA is already well advanced, and in fact more advanced now on some points that MySQL still does not support correctly, notably contractions and expansions.

And very soon I'll add support for contexts (see UTR#35 to see what I mean with those terms), because it's a trivial use of contractions and expansions, combined

But it can be implemented also as a separate function, to generate shorter keys, I'm stil not very concerned by choosing the most compact format for representing collation keys, but I have already worked a lot in how to compact automatically the sets of collation weights for each level, suppressing all unnecessary gaps that are shown in the standard DUCET table, and only provided for convenience with very basic implementation of UCA not using tailorings, or only using very basic tailorings and no contraction/expansions).

For now, the most critical algorithm (that takes most time when computing collation keys, or when directly comparing two strings) is the computing the NFD: I can save time when comparing pair of strings (for example processing only the begining of strings ontil a collation difference is found, and this does not always require strings being fully converted to NFD), but not when computing any collation key (unless I also add a constraint limiting the length of the generated collation keys, this constraint allowing to stop early). I have looked at severla implementation of Unicode normalizers in Javascript, I'm not satisfied with them as they are clearly not optimal.

In fact both the NFD transform and the generation of collation weights for each level are linked: if we sort only on primary collation level, we loose too much time in computing the NFD transform, that provides too many unnecessary details that will be finally ignored: this means that I'm also trying to perform a NFD transform, that removes these details. Such transform is effectively what the Unicode standard calls a &quot;collation mapping&quot; (something more powerful than just a &quot;case mapping&quot;, or even a &quot;case folding&quot;).

Such &quot;collation mapping&quot; would be extremely useful for implementing the &quot;first letter&quot; classification in categories, or even to provide thiner classifications in very populated categories (for example allowing two letters). This needs is in fact exactly equivalent to searching for the smallest string that has the smallest collation keys containing only two collation weights per collation level, and with a collation set to only one level, and this also can be largely optimized so that the NFD transform will remove all collation-ignorable details that would never be needed to compute the collation key.

All this is an interesting subject of research (and even ICU does not provide such a general mechanism...).

I will be also innovative in how to provide a very compact representation of tailorings. I also have ideas on how to represent, store, query and cache the precomputed lookup tables for tailorings. And on a standard interface that will allow plugable implementations in native code (if possible and needed), or for use with other languages, but also with other non-UCA based collations (including dummy collations, such as binary sorting, or sorting by standard case folding, or by standard case mappings), or complex collations requiring a lot more mapping data than the DUCET and a set of collation orders and contractions/expansions (for example for sorting Han ideographs on radical/stroke, or for sorting based on romanisations and other translitterations, that are all language-dependant; but for which I have not developed anything for now about translitterators, not even for the standard romanizations of Chinese and Japanese, that require lookup in a large dictionary, such as the huge CJK properties file found in the Unicode database as it cannot be performed algorithmically like standard romanizations of Russian or Arabic).

If you think about it more closely, ALL the existing algorithms that transform any Unicode text into another can be thought as &quot;collation mappings&quot;, based on a language-dependant definition of a multilevel collation order. Collation is the central concept, and the distinctions between algorithms are not different from distinctions between collation tailorings (a tailoring may be language-neutral, or be language-dependant).

I will expose my solutions later, first on the Unicode mailing list, on the ICU mailing list, on the jQuery maiing list, expecting that there will be interesting contributions (or useful checks and corrections), before it can become a generic library that can be reused in other projects like MediaWiki. I'll use a licence that will be compatible both with free licences (GPL-like) and open-source licences (OSI), as well as with commercial projects. It will probably be BSD-like.</pre>
    </div><div id="c233" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c233">Comment 233</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Mark A. Hershberger</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-09-01 03:11:07 UTC
        </span>
      </div>



<pre class="bz_comment_text" >This bug has been split into 4 separate bus to track the different issues raised:

    <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Use locale-specific sorting (tracking)"
   href="show_bug.cgi?id=30672">bug 30672</a> -- improve sorting on other pages than category pages (tracking)
    <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Implement central locale-specific, or tailored, sorting framework (tracking)"
   href="show_bug.cgi?id=30673">bug 30673</a> -- Support locale-specific, or tailored, sorting (tracking)
    <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Use sort collation config in JavaScript (jquery.tablesorter)"
   href="show_bug.cgi?id=30674">bug 30674</a> -- Support better client-side sorting (tracking)
    <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Use allkeys_CLDR.txt - the CLDR tailored DUCET instead of allkeys.txt"
   href="show_bug.cgi?id=30675">bug 30675</a> -- Use allkeys_CLDR.txt - the CLDR tailored DUCET instead of allkeys.txt</pre>
    </div><div id="c234" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c234">Comment 234</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philippe Verdy</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-09-03 16:52:30 UTC
        </span>
      </div>



<pre class="bz_comment_text" >Don't close this bug as long as it blocks other bugs that are not closed:

   <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Unicode (UTF-8, utf8) compatibility (tracking)"
   href="show_bug.cgi?id=3969">bug 3969</a> -- UTF-8 compatibility (tracking)
   <a class="bz_bug_link 
          bz_status_REOPENED "
   title="REOPENED - Natural number sorting in category listings"
   href="show_bug.cgi?id=6948">bug 6948</a> -- natural number sorting
   <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Swedish-language wikis should use Swedish-locale sorting (ie. ÅÄÖ should sort correctly)"
   href="show_bug.cgi?id=29788">bug 29788</a> -- sort Swedish letters correctly (at end of alphabet)

These bugs effectively depend on UCA (or UCA improvements)

My opinion is that <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Unicode (UTF-8, utf8) compatibility (tracking)"
   href="show_bug.cgi?id=3969">bug 3969</a> should be detached, but the other two should be reattached to one of the 4 new bugs, on which they depend (most probably <a class="bz_bug_link 
          bz_status_NEW "
   title="NEW - Implement central locale-specific, or tailored, sorting framework (tracking)"
   href="show_bug.cgi?id=30673">bug 30673</a>).

And the new bugs should still be linked to this <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Support collation by a certain locale (sorting order of characters)"
   href="show_bug.cgi?id=164">bug 164</a>, transformed only in a tracking number (that should not be closed as long as the new 4 bugs are open)</pre>
    </div><div id="c235" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c235">Comment 235</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Phillip Patriakeas</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-09-03 17:10:54 UTC
        </span>
      </div>



<pre class="bz_comment_text" >(In reply to <a href="show_bug.cgi?id=164#c234">comment #234</a>)
<span class="quote">&gt; Don't close this bug as long as it blocks other bugs that are not closed</span >

I thought it worked the other way around; bugs that are blocked by open bugs can't/shouldn't be closed...?</pre>
    </div><div id="c236" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c236">Comment 236</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Siebrand Mazeland</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-09-03 17:22:30 UTC
        </span>
      </div>



<pre class="bz_comment_text" >RESOLVED / FIXED per hexmode. Please leave this closed. We discussed this at length about this during the triage session.</pre>
    </div><div id="c237" class="bz_comment">

      <div class="bz_comment_head">



        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=164#c237">Comment 237</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Huji</span>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2011-09-18 17:40:08 UTC
        </span>
      </div>



<pre class="bz_comment_text" >*** <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - Implement uca-fa collation"
   href="show_bug.cgi?id=30287">Bug 30287</a> has been marked as a duplicate of this bug. ***</pre>
    </div>


  

</td>
<td>
</td>
</tr></table>
  </div>

    <hr><div id="add_comment" class="bz_section_additional_comments">
      <table>
        <tr>
          <td>
            <fieldset>
              <legend>Note</legend>
              You need to
              <a href="show_bug.cgi?id=164&amp;GoAheadAndLogIn=1">log in</a>
              before you can comment on or make changes to this bug.
            </fieldset>
          </td>
        </tr> 
      </table>
  </div>        

</form>

<hr>
<ul class="related_actions">
    <li><a href="show_bug.cgi?format=multiple&amp;id=164">Format For Printing</a></li>
    <li>&nbsp;-&nbsp;<a href="show_bug.cgi?ctype=xml&amp;id=164">XML</a></li>
    <li>&nbsp;-&nbsp;<a href="enter_bug.cgi?cloned_bug_id=164">Clone This Bug</a></li>
    
    <li>&nbsp;-&nbsp;<a href="#">Top of page </a></li>
    </ul>        


<div class="navigation">
  
  <i><font color="#777777">First</font></i>
  <i><font color="#777777">Last</font></i>
  <i><font color="#777777">Prev</font></i>
  <i><font color="#777777">Next</font></i>
  &nbsp;&nbsp;
  <i><font color="#777777">This bug is not in your last
    search results.</font></i>
</div>

<br>
<div class="visualClear"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="head" class="noprint">
			<!-- /search -->
			<div id="p-search">
				<h5><label for="searchInput">Search</label></h5>
				<form id="searchform" action="buglist.cgi" method="get"
				 onsubmit="if (this.quicksearch.value == '')
				 { alert('Please enter one or more search terms first.');
				 return false; } return true;">
					<input type='hidden' name="title" value="Special:Search"/>
					<div id="simpleSearch">
						<input id="searchInput" name="quicksearch" type="text" title="Search Bugzilla [alt-f]" accesskey="f" value="" />
						<button id="searchButton" type='submit' name='button' title="Search Bugzilla for this text">&nbsp;</button>
					</div>
				</form>
			</div>
			<!-- /search -->
			<!-- personal -->
			<div id="p-personal" class="">
				<h5>Personal tools</h5>
				<ul >
							<li id="new_account_container">
								<a href="createaccount.cgi">New&nbsp;Account</a>
							</li>
						<li id="mini_login_container">
  <span class="separator">| </span>
  <a id="login_link" href="show_bug.cgi?id=164&amp;GoAheadAndLogIn=1"
     onclick="return show_mini_login_form('')">Log In</a>

  
  <form action="show_bug.cgi?id=164" method="POST" 
        class="mini_login bz_default_hidden"
        id="mini_login"
        onsubmit="return check_mini_login_fields( '' );"
  >
    <input id="Bugzilla_login" 
           class="bz_login"
           name="Bugzilla_login"
           title="Login"
           onfocus="mini_login_on_focus('')"
    >
    <input class="bz_password" 
           id="Bugzilla_password" 
           name="Bugzilla_password"
           type="password"
           title="Password"
    >
    <input class="bz_password bz_default_hidden bz_mini_login_help" type="text" 
           id="Bugzilla_password_dummy" value="password"
           title="Password"
           onfocus="mini_login_on_focus('')"
    >
    <input type="hidden" name="Bugzilla_login_token"
           value="">
    <input type="submit" name="GoAheadAndLogIn" value="Log in"
            id="log_in">
    <script type="text/javascript">
      mini_login_constants = {
          "login" : "email address",
          "warning" : "You must set the login and password before logging in."
      };
      
      if (YAHOO.env.ua.gecko || YAHOO.env.ua.ie || YAHOO.env.ua.opera) {
          YAHOO.util.Event.onDOMReady(function() {
              init_mini_login_form('');
          });
      }
      else {
          YAHOO.util.Event.on(window, 'load', function () {
              window.setTimeout(function() {
                  init_mini_login_form('');
              }, 200);
          });
    }
    </script>
    <a href="#" onclick="return hide_mini_login_form('')">[x]</a>
  </form>
</li>
<li id="forgot_container">
  <span class="separator">| </span>
  <a id="forgot_link" href="show_bug.cgi?id=164&amp;GoAheadAndLogIn=1#forgot"
     onclick="return show_forgot_form('')">Forgot Password</a>
  <form action="token.cgi" method="post" id="forgot_form"
        class="mini_forgot bz_default_hidden">
    <label for="login">Login:</label>
    <input type="text" name="loginname" size="20" id="login">
    <input id="forgot_button" value="Reset Password" 
           type="submit">
    <input type="hidden" name="a" value="reqpw">
    <input type="hidden" id="token" name="token" value="1419356687-iofgLReLs4-foAco9bkGKnLDObwqphQZEizKxcdb7CA">
    <a href="#" onclick="return hide_forgot_form('')">[x]</a>
  </form>
</li>

				</ul>
			</div>
			<!-- /personal -->
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="panel" class="noprint">
				<!-- logo -->
				<div id="p-logo"><a style="background-image: url(skins/contrib/Wikimedia/images/bugzilla-logo.png);" href="./"  title="Visit the main page"></a></div>
				<!-- /logo -->
				<!-- navigation -->
				<div class="portal">
					<h5>Navigation</h5>
					<div class="body">
						<ul><li><a href="query.cgi?format=specific">Search bugs</a></li>
			<li><a href="query.cgi?format=advanced">Advanced search</a></li>
			<li><a href="describecomponents.cgi">Browse projects</a></li>
			<li><a href="enter_bug.cgi">Enter a new bug</a></li>
                        <li>
                                <a href="docs/en/html/bug_page.html" target="_blank">Help</a>
                        </li>	
						</ul>
					</div>
				</div>
				<!-- /navigation -->
				<!-- interaction -->
				<!-- /interaction -->
				<!-- toolbox -->
				<div class="portal">
					<h5>Links</h5>
					<div class="body">
						<ul><li><a href="report.cgi">Reports</a></li>
			<li><a href="weekly-bug-summary.cgi?tops=10&days=7">Weekly Summary</a></li>
				<li>
						<a href="request.cgi">Requests</a>
				</li>
						</ul>
					</div>
				</div>
				<!-- /toolbox -->
			</div>
		<!-- /panel -->		

		<!-- footer -->
		<div id="footer" >
			<ul id="footer-info">
				<li>Bugzilla version 4.4.5</li>
			</ul>

			<ul id="footer-places">
				<li><a href="https://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li><a href="https://www.mediawiki.org/wiki/Bug_management/Bugzilla_etiquette" title="Bug management/Bugzilla etiquette">Bugzilla etiquette</a></li>
				<li><a href="https://www.mediawiki.org/wiki/Project:About" title="Project:About">About MediaWiki.org</a></li>
				<li><a href="https://www.mediawiki.org/wiki/Project:General_disclaimer" title="Project:General disclaimer">Disclaimers</a></li>
			</ul>
			<ul id="footer-icons" class="noprint">
				<li id="footer-icon-poweredby"><a href="http://www.bugzilla.org/"><img src="skins/contrib/Wikimedia/images/bugzilla-badge.png" height="31" width="88" alt="Powered by Bugzilla" /></a></li>
			</ul>
			<div style="clear:both"></div>
		<div class="outro"></div>
		</div>
		<!-- /footer -->
	</body>
</html>